# 高频面试题

### 用户输入 url 到页面渲染的全过程

:::tip

1. 首先浏览器会对输入的内容进行预估，就是对历史访问过的网站进行匹配
2. 当用户输入 URL 时，浏览器进程会去解析，并把网络请求传给网络进程，网络进程收到请求任务后，会发起请求。在此之前，浏览器仍会保留当前页面的展示，直到收到请求响应并渲染后，才会更新页面
3. （重要）网络进程在收到请求任务后，并不会立即去发送请求，而是先检查本地是否有缓存，如果有本地缓存未过期，会走本地缓存，就是强缓存。
    - 否则会进行 DNS 解析获取 IP 地址，建立 TCP 链接，进行服务端协商缓存
4. 在 TCP 连接前，需要确认对方的身份以及位置，也就是确认 IP 地址。通过 DNS 解析获取 IP 地址，IP 地址可以被缓存，优先走缓存
    - DNS 解析会优先查看本地的 host 文件是否有映射关系表，没有的话会走本地 DNS 服务器查找，然后到顶级域名服务器找，总之最终会找到 IP 地址
    - CDN 就不用去目标服务器找，而去最近的服务器获取，资源更新的话 CDN 再向目标服务器更新
5. 找到 IP 后，会进行 TCP 三次握手。
6. 浏览器发送HTTP 请求报文
7. 服务器处理请求，返回 HTTP 响应
8. 服务端处理完请求后，结果会通过网络发回客户端的浏览器。浏览器会对服务端响应解析，状态码、请求头、请求体等。
9. 浏览器进程向渲染进程发送提交文档的信息，渲染进程收到提交文档的消息后，会和网络进程建立 IPC 通信。渲染进程会返回确认提交给浏览器进程，浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括安全状态、地址栏的 URL、前进后退的历史状态，并渲染HTML然后更新。
    - 这同时也解释了为什么在浏览器的地址栏里面输入了一个地址后，如果加载速度比较慢，之前的页面不会立马消失，而是需要等待加载一会才能把页面内容更新。
10. 接下来到了渲染进程的工作，渲染进程首先会对获取到的 HTML 字节流文件进行解析，这里会通过 HTML Parser 模块，通过分词器，将字节流分为 token，这一步的目的是把标签区分开。再对 token 进行组装，构建 DOM 树。
11. 在构建完 DOM 树后，还需要 CSS ，在拿到 CSS样式表首先会进行一次标准化，将属性值统一，这里面同时也会对百分比、继承、calc 等进行转化，生成 renderObject。但这些 CSS 还需要转成 StyleSheets
12. 在 CSSOM 和 DOM 树构建完成后，会对 DOM 树中不可见节点进行剔除，比如 head，然后会对 `display: none` 这些节点筛除，不出现在 layout tree 中，因为这些节点不会影响到布局。接下来会对节点进行布局，计算节点的坐标位置、大小
13. 接下来会对布局树进行分层，生成 Layer Tree
14. 在拿到 Layer Tree 后，会对每个图层进行绘制，会把图层的绘制拆分成很多的绘制指令，形成一个绘制指令列表，记录需要执行的绘制操作，然后 commit 到合成线程中
15. 在合成线程中会将图层进行分块，形成图块，按照视口来优先生成位图
16. 在 raster 完成后，合成线程会生成绘制图块命令 draw quad ，并生成 draw quads 给浏览器进程，viz 组件会调用 GL 指令把 draw quads 最终输出到屏幕上


在最后 commit raster 数据的时候，会有缓冲机制，通过 pending Tree 

Compositor thread 有三棵 cc::LayerImpl 树：

- Pending tree: 负责接收 commit，然后将 LayerImpl 进行 Raster
- Active tree: 会从这里取出栅格化好的 LayerImpl 进行 Draw 操作
- Recycle tree：为避免频繁创建 LayerImpl 对象，Pending tree 后续不会被销毁，而是退化成 Recycle tree。

:::

### script 会阻塞 html 嘛 css 呢

:::tip
script 的加载如果没有 defer 或者 async 的话，会在同步解析，遇到 script 标签会暂停解析，先下载 script 再执行，执行完再继续解析

如果有 defer 的话，遇到 script 会下载，但会等待 html 解析完，loaded 事件触发前执行

如果是 async 的话，遇到 script 会下载，但不会停止解析，等待 script 下载完立刻执行
:::

DOM 解析和 CSS 解析是并行的，因此 CSS 加载不会阻塞 DOM 树的解析，但是 CSS 加载会阻塞 DOM 树的渲染

- css 加载不会阻塞DOM树的解析
- css 加载会阻塞DOM树的渲染
- css 加载会阻塞后面js语句的执行

### async 和 defer 怎么用 区别

:::tip
在实践中，defer 用于需要整个 DOM 或其相对执行顺序很重要的 scripts。而 async 则用于独立的 scripts，如计数器或广告，而它们的相对执行顺序并不重要。

async 下载完立刻执行，因此和下载速度有关

defer 下载完等待 HTML 解析完成后，按顺序执行
:::

### 浏览器缓存机制？

:::tip
强缓存和协商缓存，在浏览器发起 HTTP 请求前，先会检查 Expires，和 `Cache-Control` 是否过期，如果强缓存有效，则不会发起请求，直接返回静态资源。

否则进入协商缓存，请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。 如果资源没更改，返回304，浏览器读取本地缓存。 如果资源有更改，返回200，返回最新的资源。
:::

### 重排、重绘？怎么减少重排重绘的开销？

- 重排是指当前页面中的元素布局、尺寸、位置发生变化，浏览器需要重新计算当前元素的布局信息。
- 重绘，当页面中元素视觉变化时，如颜色、背景等，不影响布局时，浏览器需要重新绘制这些元素。

减少重排重绘的开销的方法有很多

1. 避免逐个样式的变更，将多个样式更改合并到一个 CSS 类中，然后一次性添加一个类，这样只会触发一次重排重绘
2. 避免使用 table 布局，table 绘导致整个表格重排
3. 使用 transfrom、filter 这些属性来进行动画，因为这些属性的变化不会触发重排，只会重绘，而且会在合成线程执行，GPU 优化渲染
4. 对于频繁变化的元素，可以脱离文档流，不会影响到其他元素
5. 有些 DOM 访问操作会导致浏览器进行重排，如果需要多次访问这些属性，可以设置缓存，然后再使用
6. 对于大量 DOM 操作场景，可以使用 文档碎片 document fragment 或者离线 dom进行操作，避免触发多次重排重绘
7. 不可见元素可以设置 display 为 none，避免触发重排重绘

### http 和 https 区别

HTTPS 相对于 HTTP 提高了更高的安全性，HTTP 基于 3次握手就可以进行通信，HTTPS 在 HTTP 的基础上还需要进行 TLS 四次握手，对服务端身份进行确认，确保服务器可信

HTTPS 使用 TLS 对传输数据进行加密，确保数据在传输过程中的安全性，即使数据被拦截也无法轻易破解。同时 HTTPS 可以确保数据在传输过程中未被篡改，通过对数据进行数字签名，可以检测数据是否被篡改

HTTPS 的端口号是 443，HTTP 是 80

### 对称加密和非对称加密

对称加密是指加密和解密用的相同密钥的加密算法，发送方和接收方需要共享一个密钥，用于加解密，例如 HTTPS 的 ECDHE 算法，就采用的对称加密，采用非对称加密的方式生成共享密钥。

非对称加密是指在加密和解密过程中用的不同的密钥。每个用户都有一对密钥，一个公钥一个私钥。

非对称加密的优点是密钥管理简单，安全性高，比如 RSA 就是非对称加密，生成 3 个随机数。

在实际应用中，通常会将对称加密和非对称加密结合使用。例如，使用非对称加密算法安全地传输对称加密算法的密钥，然后使用对称加密算法加密和解密数据。这样既保证了数据传输的安全性，又提高了加密和解密的效率。

### TCP、UDP 以及应用场景

TCP 和 UDP 的是传输层协议 它们有一定的区别

TCP 是面向连接的可靠的数据传输协议，在数据传输前，需要通过 3 次握手来简历连接，然后通过序号、确认应答、滑动窗口，超时重传、流量控制、拥塞控制等手段来保证数据的可靠传输

而对于 UDP 而言它是无连接的，不可靠的传输协议，它不需要建立连接即可以进行数据传输，传输速度较快。在 HTTP 3 中就采用了 UDP 来做传输层协议。

采用 QUIC 结合了 TCP 的可靠性和高效性，来保证 UDP 的安全性，自己实现了一套基于帧和流的二进制传输方式，以及多路复用，同时也有超时重传等能力，保障基于 UDP 实现的不可靠问题，让 UDP 变得可靠。

对于应用场景而言，TCP 因为它的可靠性以及数据的完整性，决定了它的使用场景，网页内容、文件传输、邮件、远程登录

而 UDP 则因为它的速度快和实时性，让它在视频会议、实时通话、在线游戏等场景更受青睐

### 说说闭包会出现什么问题，内存泄漏怎么解决，闭包有什么好处？

闭包其实是 JS 里的一个很强大的特性，可能会出现内存泄漏的问题，解决内存泄漏的问题最好的方法就是及时释放内存，当闭包不需要时，就清理引用，或者对于一些场景，采用 WeakMap 建立弱引用关系，不影响垃圾回收，同时现代化浏览器的 JS 引擎其实有很好的垃圾回收机制可以用来处理闭包和内存泄漏。

闭包的好处有很多，

- 比如说在数据封装时，可以创建私有变量，这些变量对外部函数时不可见的，只能在函数内部访问。
- 闭包允许在多次调用之间保存函数的状态，可以实现缓存，记忆化能力等


### 如何避免由于 JS 加载，导致首屏字体抖动的问题

- 可以用内联 CSS
- CSS 预加载，用 preload
- 少用 JS 来改样式，或者用 async 或 defer 来调整时机
- 用 font-display swap 采用备用字体
- 使用骨架屏

### Relative 是相对于谁定位的？

Relative 是不脱离文档流的，会相对自己进行定位，而 Absolute、Fixed 会脱离文档，相对 html 或者最近的内容块定位，粘性定位也不会脱离文档流，而是相对于视口进行定位

### 进程的线程的关系？

### DNS 域名解析的过程？

### 首屏加载的优化方式

### Vite 是如何进行语法检查的？

首先 Vite 本身没有语法检查的功能，语法检查是一些插件实现的，比如 ESlint、Prettier、Babel 等，这些 Source To Source 的工具库进行转译生成符合规范的代码

他们的实现原理都是基于 AST 实现的，首先会将源码字符串解析成 AST，解析器会读取源码，然后根据 JS 规范创建 AST 节点，然后遍历 AST，访问每个节点，根据 ESLint 配置的规则来检查 AST 节点类型，遍历到相应类型的节点时，规则会检查该节点是否符合预定义的条件。如果不符合条件，ESLint 会报告一个错误或警告，收集所有规则检查的结果，并生成一个报告。报告可以输出到控制台。

同时有些插件有自动修复的功能，也是在 AST 遍历的时候进行处理的