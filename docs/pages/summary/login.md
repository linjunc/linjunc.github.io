# 面对前端鉴权登录，你需要知道的一切。从 Cookie 到 JWT、从 Session 到 SSO

在 Web 应用中，用户身份认证和授权是非常重要的一部分。为了确保应用程序的安全性和可靠性，前端鉴权登录技术成为了一个不可或缺的话题。同时在面试当中前端鉴权登录也会经常被提到相关的问题：

- 你的登录是如何实现的？
- 登录状态是如何维持的？
- 如何实现退出登录？
- ...

这篇文章将通过介绍 `Cookie`、`Session`、`JWT`、`SSO`、`oAuth` 等技术，来帮助你理解前端鉴权登录的实现原理、它们的优缺点以及它们的适用场景，以便于你在实战中能够更好的选择合适的技术来实现前端鉴权登录，同时能在面试中娓娓道来。

首先，我们需要知道为什么会有这些技术的出现，它们是为了解决什么问题的呢？

## HTTP 是无状态的

我们都知道 HTTP 是无状态的，在每次服务端接收到客户端的请求时，都会是个全新的请求，服务器并不知道这个请求**是谁发起的，也不知道这个请求是不是第一次发起的，也不知道这个请求是不是最后一次发起的**。这就意味着，每次请求都是独立的，服务器不会记录任何请求的信息，也不会记录任何客户端的信息。

举个具体的场景来说：

> 我们在访问一些电商网站时，我们会**挑选商品到购物车，然后结账**。如果我们在结账时，服务器不知道我们是谁，那么我们就需要在结账时，**再次输入我们的用户名和密码**，这样服务器才能知道我们是谁，才能完成结账的操作。

这样的操作显然是不合理的，我们在结账时，服务器应该知道我们是谁，而不是再次输入用户名和密码。

这种不合理的方式的出现也源于 **HTTP 是无状态的，服务器无法记住用户的信息。**

那么，如果 HTTP 有了状态，那么服务端就可以记住用户信息，**为什么不将 HTTP 设计成有状态的呢？**

### 为什么 HTTP 不设计成有状态的呢，而是无状态的呢？

在设计之处的考虑，一方面是为了**提高协议的可扩展性和灵活性**，确保它可以适用于各种不同的应用场景。另一方面是为了减轻服务器的负担，使其更加轻量级。因此选择了无状态的设计。

如果 HTTP 直接是有状态的，那么服务端需要跟踪每个客户端的状态信息，这样会使得服务器的**负担变大**，而且也会使得服务器的可扩展性变差。

而如果是无状态的，服务器只专注于处理一个单独的请求，不需要跟踪状态信息。同时这也**促使了客户端和服务器解耦**，每个请求都是独立的，不依赖服务器，更加灵活和动态。

那么，在 HTTP 无状态的情况下，我们如何实现状态的维持呢？

### 认证标记

接着上面电商的例子来说，我们可以使用认证标记来维持状态

我们在登录这个电商网站的时候，给你发个**通行证**，这样你可以拿着**通行证**，在这个网站里到处逛。

> 就像在公司里，你会拿着公司的门禁卡， 门禁卡上有你的信息，这样你就可以在公司里到处走动。

你在这个网站里逛了一圈，然后你想结账，你就拿着你的**通行证**去结账，这样在你结账的时候，就可以**出示你的通行证**，这样就可以知道你是谁了，就可以完成结账的操作。

因此，诞生了这一系列的设计，从网景公司发明的 Cookie，到后来 `Session`、`LocalStorage`、`IndexDB` 等技术，都为客户端处理状态信息提供了很多的解决方案。

## 根基 Cookie

Cookie 是一种存储方式，它是为了解决 HTTP 无状态导致无法跟踪用户信息而出现的。

它的出现，使得我们可以在客户端存储一些信息，然后在后续的请求中，**自动带上这些信息，这样就可以实现状态的维持。**

相比于 `LocalStorage`、`SessionStorage` 等方式，Cookie 借助浏览器的能力，可以实现跨域存储，同时可以做到前端无感知，HTTP 请求自动带上 Cookie。

### Cookie 实现状态维持的流程是怎么样的呢？

1. 首先客户端向服务端发送请求时，服务端在 HTTP 响应头中添加一个 `Set-Cookie` 字段，这个字段的值就是 Cookie 的值。包含了**唯一的会话标识**，客户端浏览器会把它存到本地。
2. 当客户端再次向服务端发送请求时，都会自动带上这个 Cookie，服务端就可以通过这个 Cookie 来**识别客户端的身份**。

![](https://ljcimg.oss-cn-beijing.aliyuncs.com/imgtwo/20230326012705.png)

> 服务端返回的 set-cookie 字段

Cookie 还有一些常用的配置项，比如 `domain`、`path`、`expires`、`httpOnly` 等，这些配置项可以用来控制 Cookie 的作用域，以及 Cookie 的有效期。

- `domain`：指定 Cookie 的**作用域**，如果不指定，默认是当前域名。如果指定了，那么 Cookie 只能在指定的域名下使用。
- `expires`：指定 Cookie 的**过期时间**，如果不指定，默认是会话结束时过期。
- `httpOnly`: 指定该 Cookie 是否只能通过 HTTP 协议来访问，如果设置了这个属性，那么通过 JS 脚本是无法访问这个 Cookie 的。
- ...

这里需要特别说到 `httpOnly` 属性，因为它是 Cookie 的一个重要属性。

对于前端而言，我们可以**自己创建 Cookie，也可以修改 Cookie**

```js
document.cookie = 'xxxx';// 伪代码
```

当然这些操作只对 `httpOnly` 为 false 的 Cookie 有效，如果是 `httpOnly` 为 true 的 Cookie，那么就无法通过 JS 来操作了。

因此，我们可以通过设置 `httpOnly` 为 true 来防止 XSS 攻击。

此外 Secure 也需要特别提一下，它是用来指定 Cookie 是否只能通过 HTTPS 协议来传输，如果设置了这个属性，那么通过 HTTP 协议是无法传输这个 Cookie 的。

它为网站提供了一定的安全性！

但不管如何，Cookie 还是通过明文传输的，还是会有一定的安全隐患。

### 需要注意的安全问题

主要有两个方面的问题：

1. Cookie 劫持
2. XSS 攻击

#### Cookie 劫持

通过**中间人攻击，拦截用户的 Cookie**，然后再次发送给服务端，这样就可以伪装成用户，从而获取用户的信息。

我们可以通过

- 升级为 HTTPS 协议加密传输数据，可以有效的防止中间人攻击和黑客窃听。
- 同时可以限制 Cookie 的过期时间，缩短 Cookie 有效时间，来减少 Cookie 劫持的风险。
- 还可以设置 `HttpOnly` 和 Secure 属性，限制 Cookie 只能在 HTTPS 协议下传输，避免被 XSS 攻击窃取。

#### XSS 攻击

在前面也有提到，客户端可以直接操作 Cookie，那么就会有被 XSS 攻击的风险，攻击者将恶意脚本注入到网页中，从而获取 Cookie 信息。

我们可以通过以下这些方式来预防 XSS 攻击：

- 对用户输入数据进行**过滤和验证**，确保所有输入的数据都符合预期。
- 使用 **CSP** 来限制脚本执行的域，防止XSS攻击。
- 设置 `httpOnly` 为 true

### 理清 Cookie 工作流程

在我们首次登录这个网站时，服务端会在 HTTP 响应头中添加 `Set-Cookie` 字段，携带 cookie 的值，cookie 的值是在服务器生成的，主要是 cookie 关联的域名、过期时间、安全连接、用户数据等内容。

在下次请求时，浏览器会**自动**带上这个 Cookie，服务端就可以通过这个 Cookie 来识别客户端的身份，进行鉴权。

**Cookie 作为维持 HTTP 请求状态的根基**，大多数前端鉴权问题都是依靠 Cookie 解决的，比如下面提到的 Session 方式

## 服务端 Session

Session 也是 Web 应用程序中常用的会话跟踪机制。它是一种**在服务器端存储用户状态信息的机制**，通常用于存储用户的身份认证信息、会话标识符等敏感数据。

它与 Cookie 不同，Session 会将用户的数据存储在服务端，并且会更具加密算法确保它的安全性。

### Session 登录流程

Session 的实现方式是当客户端第一次向服务器发送请求时，服务器会为该客户端**创建一个唯一的 SessionID**，并在自己的内存中存储 Session 数据，Session ID 则通过响应头部中的 `Set-Cookie` 字段返回给客户端浏览器。客户端再次向服务器发送请求时，会携带该 Session ID，服务端根据 Session ID 获取对应的 Session 数据以判断用户的会话状态。

![](https://ljcimg.oss-cn-beijing.aliyuncs.com/imgtwo/20230326020507.png)

> 上图是在掘金上看到的，很清晰

1. 首先客户端登录网站，发送账号密码给服务端。服务端校验密码是否成功
2. 生成一个 SessionId，把登录状态存到服务端的 session 中
3. 通过 `Set-Cookie` 把 SessionId 写入到 Cookie 中，返回给客户端
4. 此后浏览器再请求，都会自动带上 cookie
5. 服务端会根据 cookie 中的 SessionId 找到对应的 session，从而判断用户是否登录
6. 成功后，返回数据给客户端

> 可以把 session 理解为一个 Map，是键值对的形式，key 是 sessionId，value 的内容可以是用户信息，登录状态都可以

### 那么 Session 如何实现退出登录呢？

Cookie 那块没有讲退出登录的部分，这两个是一样的。

首先，退出登录无非就是**将登录状态置为未登录**，那么我们就需要清除掉 Session 中的登录状态，同时也需要清除掉 Cookie 中的 SessionId。

**那么如何清除 Cookie 中的 SessionId 呢？**

我们可以通过将 Cookie 的过期时间设置为**一个过去的时间**来实现。

### 采用 cookie + 服务端 session 会存在哪些安全问题呢？

首先，**cookie 本身是不安全的**，因为它是明文传输的，所以很容易被窃取。因此攻击者可以通过获取用户的 SessionId 来伪造用户的身份，进行恶意操作。

**可以通过以下的方式预防**

- 使用 **HTTPS** 协议加密传输数据，可以有效防止中间人攻击和黑客窃听。
- 生成**随机且复杂**的 Session ID，并设置合理的过期时间，避免被猜测或者重放攻击。
- 不要在 **URL** 中使用 Session ID，避免会话固定攻击。
- **定期更换** Session ID，以保证会话安全性。

还有一种安全问题是攻击者使用已知的 Session ID 信息，直接访问用户的会话，从而获取用户的敏感信息。

**可以通过以下的方式预防**

- 在会话开始时生成新的 Session ID，避免使用容易被猜测的 Session ID，例如递增的数字序列等。
- 使用 `HttpOnly` 和 `Secure` 属性限制 Cookie 只能在 HTTPS 协议下使用，防止被 XSS 攻击窃取。

前面我们说了很多关于服务端 Session 的东西，它需要结合 Cookie 一起使用，那么如果客户端不支持 cookie 呢？这时候怎么办？

### URL 重写 Session

URL 重写 Session 是一种**在 URL 中传递 Session ID 的方式**，不需要在客户端和服务端之间保存 Session 数据，而是通过在 URL 中添加 Session ID 来实现会话跟踪。

例如，在会话 ID为 ljc 的应用程序中，可以使用以下URL：

`http://linjunc.com/index.html?SESSIONID=ljc`

然后服务端通过检查 URL 的参数来识别会话，和存在 Cookie 的方式一样，对于前端而言就是 SessionId 存在哪里的问题。

但是这个方案也只是一个无奈的选择，因为它**不安全**，因为 URL 是明文传输的，所以很容易被窃取，攻击者可以通过获取用户的 SessionId 来伪造用户的身份，进行恶意操作。同时在部署和维护上也会带来一些麻烦。

服务端 Session 的方式相较于 Cookie 而言，安全性更高一些，但是会有两个问题：

1. 首先服务端需要存储 Session，这样就会占用一定的内存，而且 Session 也是有过期时间的，所以需要定期清理过期的 Session，这样就会带来一些性能问题。
2. 不同的服务器，无法共享 Session，通常需要借助 Redis （内存型数据库）解决

## JWT Token

前面我们说了 Cookie 和 Session 两种方案，存在着这些问题

1. 服务端 Session 需要在服务端维护，需要找地方保存它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。
2. 都基于浏览器 Cookie 实现，用户禁用 Cookie 后，系统就无法正常使用了。

那么有没有一种方案，可以解决这些问题呢？

JWT 就是这样一种方案，它是一种**基于 Token 的身份认证机制**，它的特点是**无状态**，也就是说，它不需要在服务端保存会话信息，也不需要在客户端保存会话状态。

### JWT 会话流程

### JWT 的生成规则

### JWT 的优势

### JWT 存在的问题

### JWT 如何防止被篡改

### 如何实现退出登录？

### 如何实现无感刷新？

## OAuth 2.0 的刷新机制

### 网页授权流程

### refreshToken 刷新机制

## SSO 单点登录

### SSO 登录流程

#### SSO 未登录

#### SSO 已登录

### SSO 存在的问题

### 如何防止 ticket 被篡改？

### 如何防止 ticket 被盗用？

### 防重放攻击

## 如何选择合适的前端鉴权方式？

## 总结