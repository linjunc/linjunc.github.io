---
title: 切图仔？你知道 V8 是如何执行JS代码的吗？
date: 2021-8-22 14:17:14
id: 1635408975
photos: https://ljcimg.oss-cn-beijing.aliyuncs.com/img/V8%E6%89%A7%E8%A1%8Cjs.png
tags:
  - JavaScript
categories:
  - 前端总结
keywords: V8引擎,JS运行
description: 本文将介绍 V8 引擎执行 JavaScript 代码的主要过程，清晰简单，作为一名前端人员一定要了解它！
---



> 📢 大家好，我是小丞同学，一名<font color=#2e86de>准大二的前端爱好者</font>
>
> 📢 这篇文章将带你了解 V8 是如何执行 JS 代码的
>
> 📢 <font color=#f368e0>**愿你忠于自己，热爱生活**</font>

## 引言

![image-20210822113055041](https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822113055041.png)

源代码首先通过解析器解析成 AST ，然后 AST 再通过解释器解释成最终的字节码

下面我们来聊聊解析器解析成 AST 的这个过程

首先我们先了解一下什么是 AST

## 🍉 1. 生成 AST

AST 中文名叫抽象语法树，它是源代码语法结构的一种抽象表示

它以树状的形式表现编程语言的语法结构，书上的每个节点都表示源代码中的一种结构

下面我们来一个例子看看 **AST 是如何产生的**

```js
let name = "ljc";
```

我们定义了一个 `name` 变量

解析器第一步要做的就是把这个语句拆分成最小的不可拆分的单元

![image-20210822114441105](https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822114441105.png)

生成 token 流，即语法单元成的数组

```json
[
  {
    "type": "Keyword",
    "value": "let"
  },
  {
    "type": "Identifier",
    "value": "name"
  },
  {
    "type": "Punctuator",
    "value": "="
  },
  {
    "type": "String",
    "value": "ljc"
  },
  {
    "type": "Punctuator",
    "value": ";"
  }
]
```

第二步就是语法分析

将上一步的 token 数据，转为 AST，得到一个树状结构

因此 AST 也被称为抽象语法树

在生成 AST 的同时，V8 还会生成相关的**作用域**，作用域中存放相关变量

## 🍏 2. 生成字节码

在有了 AST 和作用域之后，就可以生成字节码了，字节码是介于 AST 和机器码之间的一种代码，**可以不需要**将其转换成机器码后再执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。

那为什么需要生成字节码呢？直接转换为机器代码不是更好吗？

- 直接转换会带来内存占用过大的问题，因为如果抽象语法树全部生成机器代码，而机器代码相比于字节码，占用的内存要多的多

这是网上的一张对比图

![image-20210822122453665](https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822122453665.png)

- 某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些没有必要的代码就可以不生产机器代码，这样可以尽可能的减少占用内存过大的问题

## 🍒 3. 执行代码及优化

![image-20210822135634964](https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822135634964.png)

在上一步生成的字节码，直接被解释器执行，在代码不断地运行过程中，解释器会收到很多可以用来优化代码的信息，比如变量的类型，哪些函数执行的**频率较高**，这些信息会被发生个编译器 `TruboFan` ，它会根据这些**信息和字节码**来编译出经过优化的机器代码。

运行时几个优化策略

1. 函数只声明**未被调用**，不会被解析生成 AST
2. 函数只被调用**一次**，字节码会**直接**被解释执行
3. 函数被调用**多次**，可能会被标记为**热点函数**，可能会被编译成机器代码

**关于热点函数**

编译器 `TurboFan` 会将这些热点代码编译成更高效的机器代码储存起来，等到下次再执行时，会用现在的机器代码替换原来的字节码进行执行，这样就会大大的提示代码的执行效率。同时当 `TurboFan` 判断一段代码不再为热点代码的时候，会执行**去优化**的过程，把优化的机器码丢掉，然后执行过程回到**解释器**。

有时候解释器收集到的一些信息会是错误的，这就会导致 `TurboFan` 生成机器代码后，会被逆向还原成字节码

例如：当我们定义一个 `sum` 函数，在后面的多次调用中，它接收的两个参数我们都传的是整形，`sum` 函数被识别为热点函数，解释器将收集到的类型信息发送给编译器，编译器生成优化后的机器代码，此时当中的类型被定义为**整型**，在下次的调用中，直接执行机器代码。

而如果在下次的调用中，传入的参数是**字符串型**，机器代码不知道如何处理，就会返回给解释器解释执行

因此我们尽量**不要把一个变量的类型变来变去**，这样会对 V8 引擎带来一些影响，损失一定的性能

---

以上就是 V8 执行 JS 代码的具体流程

![v8](https://ljcimg.oss-cn-beijing.aliyuncs.com/img/v8.jpg)

在网上看到的一张图（侵删），很形象，excalidraw 上不去，不然我一定自己做了

## 参考资料

1. [《V8 是如何执行一段 JS 代码的？》](https://blog.csdn.net/React_Community/article/details/107344321?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162960012416780357221106%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162960012416780357221106&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-6-107344321.first_rank_v2_pc_rank_v29&utm_term=v8%E6%89%A7%E8%A1%8CJS%E4%BB%A3%E7%A0%81&spm=1018.2226.3001.4187)
2. [《【干货】8 分钟带你了解 V8 引擎是如何运行 JS！》](https://www.bilibili.com/video/BV1zV411z7RX?from=search&seid=11844131633111646720)

> 非常感谢您的阅读，欢迎提出你的意见，有什么问题欢迎指出，谢谢！🎈
