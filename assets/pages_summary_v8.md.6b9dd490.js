import{_ as s,c as a,o as n,U as o}from"./chunks/framework.4d5e0f31.js";const A=JSON.parse('{"title":"切图仔？你知道 V8 是如何执行JS代码的吗？","description":"本文将介绍 V8 引擎执行 JavaScript 代码的主要过程，清晰简单，作为一名前端人员一定要了解它！","frontmatter":{"title":"切图仔？你知道 V8 是如何执行JS代码的吗？","date":"2021-08-22T14:17:14.000Z","id":1635408975,"photos":"https://ljcimg.oss-cn-beijing.aliyuncs.com/img/V8%E6%89%A7%E8%A1%8Cjs.png","tags":["JavaScript"],"categories":["前端总结"],"keywords":"V8引擎,JS运行","description":"本文将介绍 V8 引擎执行 JavaScript 代码的主要过程，清晰简单，作为一名前端人员一定要了解它！"},"headers":[],"relativePath":"pages/summary/v8.md","lastUpdated":1686994789000}'),p={name:"pages/summary/v8.md"},l=o(`<blockquote><p>📢 大家好，我是小丞同学，一名<div color="#2e86de">准大二的前端爱好者</div></p><p>📢 这篇文章将带你了解 V8 是如何执行 JS 代码的</p><p>📢 <div color="#f368e0"><strong>愿你忠于自己，热爱生活</strong></div></p></blockquote><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822113055041.png" alt="image-20210822113055041" data-fancybox="gallery"></p><p>源代码首先通过解析器解析成 AST ，然后 AST 再通过解释器解释成最终的字节码</p><p>下面我们来聊聊解析器解析成 AST 的这个过程</p><p>首先我们先了解一下什么是 AST</p><h2 id="🍉-1-生成-ast" tabindex="-1">🍉 1. 生成 AST <a class="header-anchor" href="#🍉-1-生成-ast" aria-label="Permalink to &quot;🍉 1. 生成 AST&quot;">​</a></h2><p>AST 中文名叫抽象语法树，它是源代码语法结构的一种抽象表示</p><p>它以树状的形式表现编程语言的语法结构，书上的每个节点都表示源代码中的一种结构</p><p>下面我们来一个例子看看 <strong>AST 是如何产生的</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ljc</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>我们定义了一个 <code>name</code> 变量</p><p>解析器第一步要做的就是把这个语句拆分成最小的不可拆分的单元</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822114441105.png" alt="image-20210822114441105" data-fancybox="gallery"></p><p>生成 token 流，即语法单元成的数组</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Keyword</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">let</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Identifier</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">name</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Punctuator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">=</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">String</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ljc</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Punctuator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">;</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><p>第二步就是语法分析</p><p>将上一步的 token 数据，转为 AST，得到一个树状结构</p><p>因此 AST 也被称为抽象语法树</p><p>在生成 AST 的同时，V8 还会生成相关的<strong>作用域</strong>，作用域中存放相关变量</p><h2 id="🍏-2-生成字节码" tabindex="-1">🍏 2. 生成字节码 <a class="header-anchor" href="#🍏-2-生成字节码" aria-label="Permalink to &quot;🍏 2. 生成字节码&quot;">​</a></h2><p>在有了 AST 和作用域之后，就可以生成字节码了，字节码是介于 AST 和机器码之间的一种代码，<strong>可以不需要</strong>将其转换成机器码后再执行，字节码可以理解为是机器码的一种抽象。Ignition 解释器除了可以快速生成没有优化的字节码外，还可以执行部分字节码。</p><p>那为什么需要生成字节码呢？直接转换为机器代码不是更好吗？</p><ul><li>直接转换会带来内存占用过大的问题，因为如果抽象语法树全部生成机器代码，而机器代码相比于字节码，占用的内存要多的多</li></ul><p>这是网上的一张对比图</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822122453665.png" alt="image-20210822122453665" data-fancybox="gallery"></p><ul><li>某些 JavaScript 使用场景使用解释器更为合适，解析成字节码，有些没有必要的代码就可以不生产机器代码，这样可以尽可能的减少占用内存过大的问题</li></ul><h2 id="🍒-3-执行代码及优化" tabindex="-1">🍒 3. 执行代码及优化 <a class="header-anchor" href="#🍒-3-执行代码及优化" aria-label="Permalink to &quot;🍒 3. 执行代码及优化&quot;">​</a></h2><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822135634964.png" alt="image-20210822135634964" data-fancybox="gallery"></p><p>在上一步生成的字节码，直接被解释器执行，在代码不断地运行过程中，解释器会收到很多可以用来优化代码的信息，比如变量的类型，哪些函数执行的<strong>频率较高</strong>，这些信息会被发生个编译器 <code>TruboFan</code> ，它会根据这些<strong>信息和字节码</strong>来编译出经过优化的机器代码。</p><p>运行时几个优化策略</p><ol><li>函数只声明<strong>未被调用</strong>，不会被解析生成 AST</li><li>函数只被调用<strong>一次</strong>，字节码会<strong>直接</strong>被解释执行</li><li>函数被调用<strong>多次</strong>，可能会被标记为<strong>热点函数</strong>，可能会被编译成机器代码</li></ol><p><strong>关于热点函数</strong></p><p>编译器 <code>TurboFan</code> 会将这些热点代码编译成更高效的机器代码储存起来，等到下次再执行时，会用现在的机器代码替换原来的字节码进行执行，这样就会大大的提示代码的执行效率。同时当 <code>TurboFan</code> 判断一段代码不再为热点代码的时候，会执行<strong>去优化</strong>的过程，把优化的机器码丢掉，然后执行过程回到<strong>解释器</strong>。</p><p>有时候解释器收集到的一些信息会是错误的，这就会导致 <code>TurboFan</code> 生成机器代码后，会被逆向还原成字节码</p><p>例如：当我们定义一个 <code>sum</code> 函数，在后面的多次调用中，它接收的两个参数我们都传的是整形，<code>sum</code> 函数被识别为热点函数，解释器将收集到的类型信息发送给编译器，编译器生成优化后的机器代码，此时当中的类型被定义为<strong>整型</strong>，在下次的调用中，直接执行机器代码。</p><p>而如果在下次的调用中，传入的参数是<strong>字符串型</strong>，机器代码不知道如何处理，就会返回给解释器解释执行</p><p>因此我们尽量<strong>不要把一个变量的类型变来变去</strong>，这样会对 V8 引擎带来一些影响，损失一定的性能</p><hr><p>以上就是 V8 执行 JS 代码的具体流程</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/v8.jpg" alt="v8" data-fancybox="gallery"></p><p>在网上看到的一张图（侵删），很形象，excalidraw 上不去，不然我一定自己做了</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ol><li><a href="https://blog.csdn.net/React_Community/article/details/107344321?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162960012416780357221106%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162960012416780357221106&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v29_ecpm-6-107344321.first_rank_v2_pc_rank_v29&amp;utm_term=v8%E6%89%A7%E8%A1%8CJS%E4%BB%A3%E7%A0%81&amp;spm=1018.2226.3001.4187" target="_blank" rel="noreferrer">《V8 是如何执行一段 JS 代码的？》</a></li><li><a href="https://www.bilibili.com/video/BV1zV411z7RX?from=search&amp;seid=11844131633111646720" target="_blank" rel="noreferrer">《【干货】8 分钟带你了解 V8 引擎是如何运行 JS！》</a></li></ol><blockquote><p>非常感谢您的阅读，欢迎提出你的意见，有什么问题欢迎指出，谢谢！🎈</p></blockquote>`,45),t=[l];function e(c,r,D,i,y,F){return n(),a("div",null,t)}const C=s(p,[["render",e]]);export{A as __pageData,C as default};
