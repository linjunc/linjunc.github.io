import{_ as a,c as e,o as t,U as l}from"./chunks/framework.4d5e0f31.js";const u=JSON.parse('{"title":"面试被问到的计网","description":"","frontmatter":{},"headers":[],"relativePath":"pages/network/interview-network.md","lastUpdated":1687077803000}'),i={name:"pages/network/interview-network.md"},o=l('<h1 id="面试被问到的计网" tabindex="-1">面试被问到的计网 <a class="header-anchor" href="#面试被问到的计网" aria-label="Permalink to &quot;面试被问到的计网&quot;">​</a></h1><h2 id="前端缓存-如果是你-你会怎么配置各种资源文件的缓存呢" tabindex="-1">前端缓存？如果是你，你会怎么配置各种资源文件的缓存呢？ <a class="header-anchor" href="#前端缓存-如果是你-你会怎么配置各种资源文件的缓存呢" aria-label="Permalink to &quot;前端缓存？如果是你，你会怎么配置各种资源文件的缓存呢？&quot;">​</a></h2><h2 id="tcp-ip-是如何实现可靠传输的-有哪些具体的做法" tabindex="-1">TCP/IP 是如何实现可靠传输的？有哪些具体的做法？ <a class="header-anchor" href="#tcp-ip-是如何实现可靠传输的-有哪些具体的做法" aria-label="Permalink to &quot;TCP/IP 是如何实现可靠传输的？有哪些具体的做法？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>超时重传的含义，具体做法</p><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li><li>拥塞控制：当网络拥塞时，减少数据的发送。</li></ol></div><h2 id="常见的-http-method-有哪些-get-post-区别" tabindex="-1">常见的 HTTP Method 有哪些？GET/POST 区别？ <a class="header-anchor" href="#常见的-http-method-有哪些-get-post-区别" aria-label="Permalink to &quot;常见的 HTTP Method 有哪些？GET/POST 区别？&quot;">​</a></h2><h2 id="header-中常见的-key-value-对有哪些" tabindex="-1">Header 中常见的 key/value 对有哪些？ <a class="header-anchor" href="#header-中常见的-key-value-对有哪些" aria-label="Permalink to &quot;Header 中常见的 key/value 对有哪些？&quot;">​</a></h2><h2 id="http-协议是应用成协议-其网络传输层的协议是什么" tabindex="-1">HTTP 协议是应用成协议，其网络传输层的协议是什么？ <a class="header-anchor" href="#http-协议是应用成协议-其网络传输层的协议是什么" aria-label="Permalink to &quot;HTTP 协议是应用成协议，其网络传输层的协议是什么？&quot;">​</a></h2><h2 id="header-中能存放二进制数据么" tabindex="-1">Header 中能存放二进制数据么？ <a class="header-anchor" href="#header-中能存放二进制数据么" aria-label="Permalink to &quot;Header 中能存放二进制数据么？&quot;">​</a></h2><h2 id="tcp-四次挥手为什么要有-time-wait-状态-为什么" tabindex="-1">TCP 四次挥手为什么要有 TIME_WAIT 状态？为什么？ <a class="header-anchor" href="#tcp-四次挥手为什么要有-time-wait-状态-为什么" aria-label="Permalink to &quot;TCP 四次挥手为什么要有 TIME_WAIT 状态？为什么？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>保证 TCP 协议全双工连接能够可靠关闭，直接关闭的话，如果服务器没有收到 ACK，会重复发 FIN。</li><li>保证这次连接的重复数据从网络中消失，如果上次的 socket 和这次的 socket 处理的程序一样，就会导致这次连接把上次的数据加进来了。</li></ul></div><h2 id="tcp-ip-的拥塞控制的含义是什么-有什么拥塞控制的方法" tabindex="-1">TCP/IP 的拥塞控制的含义是什么，有什么拥塞控制的方法？ <a class="header-anchor" href="#tcp-ip-的拥塞控制的含义是什么-有什么拥塞控制的方法" aria-label="Permalink to &quot;TCP/IP 的拥塞控制的含义是什么，有什么拥塞控制的方法？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</li><li>对比流量控制：拥塞控制是一个全局的过程，涉及到所有的主机、路由器、以及降低网络相关的所有因素。流量控制往往指点对点通信量的控制。是端对端的问题。</li><li>几种拥塞控制的方法： 慢开始，拥塞避免，快重传，快恢复。</li></ul><ol><li>慢开始：主机开发发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。</li><li>拥塞避免：是让 cwnd 缓慢的增加而不是加倍的增长，每经历过一次往返时间就使 cwnd 增加 1，而不是加倍，这样使 cwnd 缓慢的增长，比慢启动要慢的多。</li><li>快重传：快重传算法要求首先接收方收到一个失序的报文段后立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。</li><li>快恢复：当发送方连续接到三个确认时，就执行乘法减小算法，把慢开始门限减半，但是接下来并不执行慢开始算法。而是把 cwnd 设置为 ssthresh 的一半，然后执行拥塞避免算法，使拥塞窗口缓慢增大。</li></ol></div><h2 id="描述-tcp-和-udp-的区别和各自的应用场景" tabindex="-1">描述 TCP 和 UDP 的区别和各自的应用场景 <a class="header-anchor" href="#描述-tcp-和-udp-的区别和各自的应用场景" aria-label="Permalink to &quot;描述 TCP 和 UDP 的区别和各自的应用场景&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>TCP 是面向连接且可靠的，UDP 是面向非连接且非可靠</li><li>TCP 是面向字节流的，UDP 是面向报文流</li><li>TCP 的传输效率低，UDP 传输效率高</li><li>TCP 有流量控制，拥塞控制等，UDP 没有</li><li>TCP 适用于对可靠性要求比较高，但对效率要求低的场景，而 UDP 适用于对可靠性要求比较低，但对效率要求比较高的场景</li><li>TCP 协议应用: HTTP/FTP/TELNET/SMTP UDP 协议应用: DNS/SNMP</li></ol></div>',14),r=[o];function c(s,d,h,P,n,T){return t(),e("div",null,r)}const k=a(i,[["render",c]]);export{u as __pageData,k as default};
