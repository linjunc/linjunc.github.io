(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{440:function(t,s,a){t.exports=a.p+"assets/img/1.5dbbb261.png"},441:function(t,s,a){t.exports=a.p+"assets/img/2.f7b3f346.png"},442:function(t,s,a){t.exports=a.p+"assets/img/3.c7702cfc.png"},443:function(t,s,a){t.exports=a.p+"assets/img/4.2c16991d.png"},444:function(t,s,a){t.exports=a.p+"assets/img/5.403542ca.png"},484:function(t,s,a){"use strict";a.r(s);var e=a(65),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("在 "),e("code",[t._v("beginWork")]),t._v("那一节我们知道了，在 "),e("code",[t._v("reconcileChildren")]),t._v(" 中，会根据当前的 "),e("code",[t._v("current")]),t._v(" 是否存在，来判断是进入 "),e("code",[t._v("update")]),t._v(" 还是 "),e("code",[t._v("mount")]),t._v(" 的逻辑"),e("br"),t._v("在 "),e("code",[t._v("update")]),t._v("时，会维护两棵虚拟 DOM 树，React 在每次更新时，都会将本次的新的内容与旧的 Fiber 树进行对比，通过 Diff 算法比较他们之间的差异后，构建新的 Fiber 树，将计算好的需要更新的节点放入更新队列中，从而在 commti 阶段，依据这个 Diff 结果，对真实 DOM 进行更新渲染。"),e("br"),t._v("这样可以确保通过"),e("strong",[t._v("最小的代价来将旧的 Fiber 树转化为新的 Fiber 树")]),t._v("，以保证 UI 与新的树保持同步")]),t._v(" "),e("h2",{attrs:{id:"虚拟-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),e("p",[t._v("虚拟 DOM ，它是一种编程概念，在这个概念里，以一种"),e("strong",[t._v("虚拟的表现形式被保存在内存")]),t._v("中。在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而是 JavaScript 对象")]),t._v(" "),e("blockquote",[e("p",[t._v("虚拟 DOM 只保留了真实 DOM 节点的一些"),e("strong",[t._v("基本属性，和节点之间的层次关系")]),t._v("，它相当于建立在 JavaScript 和 DOM 之间的一层“缓存”")])]),t._v(" "),e("div",{staticClass:"language-html line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("class")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("hello"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("span")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("hello world!"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("span")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("上面的这段代码会转化可以转化为虚拟 DOM 结构")]),t._v(" "),e("div",{staticClass:"language-json line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-json"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    tag"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"div"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    props"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        class"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    children"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        tag"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"span"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        props"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        children"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("p",[t._v("其中对于一个节点必备的"),e("strong",[t._v("三个属性")]),t._v(" "),e("code",[t._v("tag、props、children")])]),t._v(" "),e("ul",[e("li",[t._v("tag 指定元素的"),e("strong",[t._v("标签")]),t._v("类型，如"),e("code",[t._v("li")]),t._v("，"),e("code",[t._v("div")])]),t._v(" "),e("li",[t._v("props 指定元素身上的属性，如 "),e("code",[t._v("class")]),t._v(" ，"),e("code",[t._v("style")]),t._v("，自定义属性")]),t._v(" "),e("li",[t._v("children 指定元素是否有"),e("strong",[t._v("子节点")]),t._v("，参数以"),e("strong",[t._v("数组")]),t._v("形式传入")])]),t._v(" "),e("p",[t._v("而我们在 render 中编写的 JSX 代码就是一种虚拟 DOM 结构。")]),t._v(" "),e("h2",{attrs:{id:"diff-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-策略"}},[t._v("#")]),t._v(" Diff 策略")]),t._v(" "),e("p",[t._v("那么基于多叉树的 Diff 算法，如果需要完整的对比之间的差异，"),e("strong",[t._v("复杂度会达到 O(n^3)")]),t._v("，也就是 1000 个元素需要进行 10 亿次的比较，这个开销非常之大，React "),e("strong",[t._v("基于一些策略")]),t._v("，来实现了 O(n) 复杂度的 Diff 算法")]),t._v(" "),e("ol",[e("li",[t._v("只对"),e("strong",[t._v("同级元素")]),t._v("进行 diff ，如果 dom 前后两次更新跨层级，不会复用，而作为新元素")]),t._v(" "),e("li",[t._v("两个"),e("strong",[t._v("不同类型的元素")]),t._v("会产生出不同的树。如 div 变成 p 会将整棵树销毁")]),t._v(" "),e("li",[t._v("可以通过** key** 来暗示不同的渲染下保持稳定")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(440),alt:"image.png"}}),e("br"),t._v("而针对这三种策略，分别对应着** **"),e("code",[t._v("tree diff")]),t._v("，"),e("code",[t._v("component diff")]),t._v(" 以及 "),e("code",[t._v("element diff")]),t._v(" 来进行算法优化")]),t._v(" "),e("h3",{attrs:{id:"按-tree-层级-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按-tree-层级-diff"}},[t._v("#")]),t._v(" 按 Tree 层级 Diff")]),t._v(" "),e("p",[t._v("首先会将新旧两个 DOM 树，进行比较，这个比较指的是"),e("strong",[t._v("分层比较")]),t._v("。又由于 DOM 节点"),e("strong",[t._v("跨层级的移动操作很少，忽略不计")]),t._v("。React 通过 "),e("code",[t._v("updataDepth")]),t._v(" 对 虚拟 DOM 树进行层级控制，只会对同层节点进行比较，也就是图中只会对相同颜色方框内的 DOM 节点进行比较。例如："),e("br"),e("strong",[t._v("当对比发现节点消失时，则该节点及其子节点都会被完全删除，不会进行更深层次的比较")]),t._v("，这样只需要对树进行一次遍历，便能完成整颗 DOM 树的比较"),e("br"),e("img",{attrs:{src:a(441),alt:"image.png"}})]),t._v(" "),e("p",[t._v("这里还有一个值得关注的地方："),e("strong",[t._v("DOM 节点跨层级移动")]),e("br"),t._v("为什么会提出这样的问题呢，在上面的删除原则中，我们发现当节点不存在了就会删除，那我只是给它换位了，它也会删除整个节点及其子节点吗？"),e("br"),e("img",{attrs:{src:a(442),alt:"image.png"}}),e("br"),t._v("如图，我们需要实现这样的移动，你可能会以为它会直接这样移动"),e("br"),e("img",{attrs:{src:a(443),alt:"image.png"}}),e("br"),t._v("但是实际情况，并不是这样的。由于 React 只会简单的进行同层级节点位置变化，对于不同层级的节点，只有创建和删除操作，当发现 B 节点消失时，就会"),e("strong",[t._v("销毁 B")]),t._v("，当发现 C 节点上多了 B 节点，就会创建 B 以及它的子节点。"),e("br"),e("strong",[t._v("因此这样会非常的复杂，所以 React 官方并不建议我们进行 DOM 节点跨级操作")])]),t._v(" "),e("h3",{attrs:{id:"按-component-层级-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按-component-层级-diff"}},[t._v("#")]),t._v(" 按 component 层级 diff")]),t._v(" "),e("p",[t._v("在组件层面上，也进行了优化")]),t._v(" "),e("ul",[e("li",[t._v("如果是同一类型的组件，则按照原策略继续比较 虚拟 DOM Tree")]),t._v(" "),e("li",[t._v("如果不是，则将这个组件记为 "),e("code",[t._v("dirty component")]),t._v(" ，从而"),e("strong",[t._v("替换整个组件下的所有子节点")])])]),t._v(" "),e("p",[t._v("同时对于同一类型的组件，有可能其 "),e("code",[t._v("Virtual DOM")]),t._v(" 没有任何变化，如果能够确切的知道这点就可以节省大量的 "),e("code",[t._v("diff")]),t._v(" 运算的时间，因此 "),e("code",[t._v("React")]),t._v(" 允许用户通过 "),e("code",[t._v("shouldComponentUpdate()")]),t._v(" 判断该组件是否需要进行 "),e("code",[t._v("diff")]),t._v(" 算法分析"),e("br"),t._v("总的来说，"),e("strong",[t._v("如果两个组件结构相似，但被认定为了不同类型的组件，则不会比较二者的结构，而是直接删除")])]),t._v(" "),e("h3",{attrs:{id:"按-element-层级-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按-element-层级-diff"}},[t._v("#")]),t._v(" 按 element 层级 diff")]),t._v(" "),e("p",[t._v("element diff 是专门针对"),e("strong",[t._v("同一层级的所有节点")]),t._v("的策略。当节点在同一层级时，diff 提供了 3个节点操作方法：插入，移动，删除"),e("br"),t._v("当我们要完成如图所示操作转化时，会有很大的困难，因为在新老节点比较的过程中，发现每个节点都要"),e("strong",[t._v("删除再重新创建")]),t._v("，但是这只是重新排序了而已，对性能极大的不友好。因此 React 中提出了优化策略："),e("br"),t._v("允许添加"),e("strong",[t._v("唯一值 key 来区分节点")]),e("br"),e("img",{attrs:{src:a(444),alt:"image.png"}}),e("br"),t._v("引入 key 的优化策略，让性能上有了翻天覆地的变化")]),t._v(" "),e("h4",{attrs:{id:"那-key-有什么作用呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那-key-有什么作用呢"}},[t._v("#")]),t._v(" 那 key 有什么作用呢？")]),t._v(" "),e("p",[t._v("当同一层级的节点添加了 key 属性后，当位置发生变化时。react diff 进行新旧节点比较，如果发现有相同的 key 就会进行移动操作，而不会删除再创建")]),t._v(" "),e("h4",{attrs:{id:"那-key-具体是如何起作用的呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那-key-具体是如何起作用的呢"}},[t._v("#")]),t._v(" 那 key 具体是如何起作用的呢？")]),t._v(" "),e("p",[t._v("首先在 React 中只允许"),e("strong",[t._v("节点右移")]),e("br"),t._v("因此对于上图中的转化，只会进行 A，C 的移动"),e("br"),t._v("则只需要对移动的节点进行更新渲染，不移动的则不需要更新渲染")]),t._v(" "),e("h4",{attrs:{id:"为什么不能用-index-作为-key-值呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能用-index-作为-key-值呢"}},[t._v("#")]),t._v(" 为什么不能用 index 作为 key 值呢？")]),t._v(" "),e("p",[e("code",[t._v("index")]),t._v(" 作为 "),e("code",[t._v("key")]),t._v(" ，如果我们删除了一个节点，那么数组的后一项可能会前移，这个时候移动的节点和删除的节点就是相同的 "),e("code",[t._v("key")]),t._v("  ，在"),e("code",[t._v("react")]),t._v("中，如果 "),e("code",[t._v("key")]),t._v(" 相同，就会视为"),e("strong",[t._v("相同的组件")]),t._v("，但这两个组件是不同的，这样就会出现很麻烦的事情，例如：序号和文本不对应等问题"),e("br"),t._v("所以一定要保证 "),e("code",[t._v("key")]),t._v(" 的唯一性")]),t._v(" "),e("h2",{attrs:{id:"建议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#建议"}},[t._v("#")]),t._v(" 建议")]),t._v(" "),e("p",[t._v("React 已经帮我们做了很多了，剩下的需要我们多加注意，才能有更好的性能"),e("br"),t._v("基于三个策略我们需要注意")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("tree diff 建议")]),t._v("：开发组件时，需要注意保持 DOM 结构稳定")]),t._v(" "),e("li",[e("strong",[t._v("component diff 建议")]),t._v("：使用 "),e("code",[t._v("shouldComponentUpdate()")]),t._v(" 来减少不必要的更新")]),t._v(" "),e("li",[e("strong",[t._v("element diff 建议")]),t._v("：减少最后一个节点移动到头部的操作，这样前面的节点都需要移动")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("下节开始，我们将会介绍 React 源码中的 "),e("strong",[t._v("Diff 算法")]),t._v("的实现，它可以根据"),e("strong",[t._v("同级节点的数量分为两类")])]),t._v(" "),e("ul",[e("li",[t._v("一种是用于 "),e("code",[t._v("object")]),t._v("、"),e("code",[t._v("number")]),t._v("、"),e("code",[t._v("string")]),t._v(" 类型的节点，这些都是单一节点的 Diff")]),t._v(" "),e("li",[t._v("一种是 "),e("code",[t._v("array")]),t._v(" 类型的多节点 Diff")])]),t._v(" "),e("p",[t._v("我们将分为两节来介绍，下节介绍单一节点的 Diff 算法")]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000016539430",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈React中Diff算法的策略及实现"),e("OutboundLink")],1),e("br"),e("a",{attrs:{href:"https://segmentfault.com/a/1190000011492275",target:"_blank",rel:"noopener noreferrer"}},[t._v("React diff算法"),e("OutboundLink")],1),e("br"),e("a",{attrs:{href:"https://juejin.cn/post/6967626390380216334#heading-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈react 虚拟dom，diff算法与key机制"),e("OutboundLink")],1)]),t._v(" "),e("hr")])}),[],!1,null,null,null);s.default=n.exports}}]);