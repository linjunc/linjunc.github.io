(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{445:function(e,t,a){e.exports=a.p+"assets/img/idea.66619dbb.png"},446:function(e,t,a){e.exports=a.p+"assets/img/9.31045b00.jpeg"},485:function(e,t,a){"use strict";a.r(t);var r=a(65),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[r("img",{attrs:{src:a(445),alt:"image.png"}})]),e._v(" "),r("p",[e._v("React 是用 JavaScript 构建"),r("strong",[e._v("快速响应")]),e._v("的大型 Web 应用程序的首选方式。")]),e._v(" "),r("p",[e._v("设计理念：快速响应")]),e._v(" "),r("p",[e._v("制约瓶颈：CPU 与 IO 瓶颈")]),e._v(" "),r("ul",[r("li",[e._v("当遇到大计算量的操作或者设备性能不足时页面掉帧，"),r("strong",[e._v("导致卡顿")]),e._v("。")]),e._v(" "),r("li",[e._v("发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。")])]),e._v(" "),r("p",[e._v("解决方法：实现异步可中断的更新")]),e._v(" "),r("h2",{attrs:{id:"老的-react-架构-react-15"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#老的-react-架构-react-15"}},[e._v("#")]),e._v(" 老的 React 架构（React 15）")]),e._v(" "),r("p",[e._v("React15 架构可以分为两层：")]),e._v(" "),r("ul",[r("li",[e._v("Reconciler（协调器）—— 负责找出变化的组件（Diff 算法）")]),e._v(" "),r("li",[e._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])]),e._v(" "),r("p",[e._v("Diff 算法将上一次更新的组件和本次更新的组件做对比，被判定为需要更新的组件，会被交给渲染器进行渲染，不同的渲染器会将不同的组件渲染到不同的宿主环境的视图中")]),e._v(" "),r("h3",{attrs:{id:"reconcile-协调器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reconcile-协调器"}},[e._v("#")]),e._v(" Reconcile 协调器")]),e._v(" "),r("p",[r("strong",[e._v("在 React 15 中采用的是 stack reconciler 解决方案")])]),e._v(" "),r("p",[e._v("可以通过 "),r("code",[e._v("this.setState")]),e._v(" 等 API 来触发更新，每次 "),r("code",[e._v("update")]),e._v(" 时，协调器就会开始它的工作")]),e._v(" "),r("ul",[r("li",[e._v("首先会开始 "),r("code",[e._v("render")]),e._v(" 阶段的执行，"),r("strong",[e._v("将 JSX 转化成 Fiber Virtual DOM")])]),e._v(" "),r("li",[e._v("接着会前后两次的 Virtual DOM 进行对比，也就是 "),r("strong",[e._v("Diff 算法")]),e._v("的工作，会对变更的节点打上对应的操作类型 effectTag")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("commit")]),e._v(" 阶段，会找到本次更新中变化的 Virtual DOM 节点")]),e._v(" "),r("li",[e._v("通知 "),r("code",[e._v("Renderer")]),e._v(" 渲染器"),r("strong",[e._v("更新对应的视图")])])]),e._v(" "),r("h3",{attrs:{id:"renderer-渲染器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#renderer-渲染器"}},[e._v("#")]),e._v(" Renderer 渲染器")]),e._v(" "),r("p",[e._v("React 最初只是服务于 DOM，但是这之后被改编成也能同时"),r("strong",[e._v("支持原生平台的 React Native")]),e._v("。因此，在 React 内部机制中引入了“渲染器”这个概念。")]),e._v(" "),r("p",[r("strong",[e._v("渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("React DOM Renderer")]),e._v("： 将 React 组件渲染成 DOM。它实现了全局 ReactDOMAPI，这在npm上作为 react-dom 包。这也可以作为单独浏览器版本使用，称为 react-dom.js，导出一个 ReactDOM 的全局对象.")]),e._v(" "),r("li",[r("strong",[e._v("React Native Renderer")]),e._v("： 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。")]),e._v(" "),r("li",[r("strong",[e._v("React Test Renderer")]),e._v("： 将 React 组件渲染为 JSON 树。这用于 Jest 的快照测试特性。在 npm 上作为 react-test-renderer 包发布。\n另外一个官方支持的渲染器的是 react-art。它曾经是一个独立的 GitHub 仓库，但是现在我们将此加入了主源代码树。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.npmjs.com/package/react-art",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactArt Renderer"),r("OutboundLink")],1),e._v(" ：渲染到 Canvas, SVG 或 VML (IE8)")])]),e._v(" "),r("p",[e._v("在每次更新发生时，"),r("strong",[e._v("Renderer")]),e._v(" 接到 "),r("strong",[e._v("Reconciler")]),e._v(" 通知，将变化的组件渲染在当前宿主环境。")]),e._v(" "),r("h2",{attrs:{id:"react15-架构的缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react15-架构的缺点"}},[e._v("#")]),e._v(" React15 架构的缺点")]),e._v(" "),r("p",[e._v("在 "),r("code",[e._v("Reconciler")]),e._v(" 阶段， 会递归的更新子组件，调用 "),r("code",[e._v("mount Component")]),e._v(" 或 "),r("code",[e._v("update Component")]),e._v(" 来实现，这也成为了它致命的缺点，"),r("strong",[e._v("一旦更新无法中断")])]),e._v(" "),r("h3",{attrs:{id:"递归更新的缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#递归更新的缺点"}},[e._v("#")]),e._v(" 递归更新的缺点")]),e._v(" "),r("p",[e._v("当组件的层级很深时，无法在一帧内完成更新，又没有办法中断本次更新，用户交互就会变得卡顿")]),e._v(" "),r("p",[e._v("在 React 15 架构中，采用同步更新的方式，"),r("code",[e._v("Reconciler")]),e._v(" 和 "),r("code",[e._v("Renderer")]),e._v(" 是交替工作的，只有当前一个 DOM 完成了 "),r("code",[e._v("renderer")]),e._v(" 才会"),r("strong",[e._v("进入下一个")]),e._v(" DOM 的 "),r("code",[e._v("Reconciler")])]),e._v(" "),r("p",[e._v("在用户看来所有的 DOM 是同时更新的。")]),e._v(" "),r("p",[e._v("在前面说到，React 为了践行快速响应的理念，需要实现异步可中断的更新，那么基于 React 15 的架构能够实现吗？")]),e._v(" "),r("p",[r("strong",[e._v("我们来演示一下在 React 15 架构下，如果触发更新的中断会发生什么？")])]),e._v(" "),r("p",[e._v("在下面的列子中，左边是更新前的页面，当我们点击时，会触发左侧数字 "),r("code",[e._v("count + 1")]),e._v("。正常情况，我们应当看到页面为 "),r("code",[e._v("2 3 4")]),e._v("。")]),e._v(" "),r("p",[e._v("当 2 更新为 3 后，我们中断了更新，由于 React 15 采用的是递归的更新，在上一个 DOM 完成更新之后才会开始下一个 DOM 的更新，因此就会看到右侧的页面，也就是 "),r("code",[e._v("2 3 3")]),e._v("，用户却"),r("strong",[e._v("看不到期望的值")]),e._v("，也因此有了 React 16 的 Fiber 架构")]),e._v(" "),r("p",[r("img",{attrs:{src:a(446),alt:"image.png"}})]),e._v(" "),r("h2",{attrs:{id:"新的-react-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新的-react-架构"}},[e._v("#")]),e._v(" 新的 React 架构")]),e._v(" "),r("p",[e._v("在 React 16 版本中进行了一次大的重构，React 16 架构"),r("strong",[e._v("解决了 React 15 不能支撑异步更新的问题")]),e._v("\nReact16 架构可以分为三层：")]),e._v(" "),r("ul",[r("li",[e._v("Scheduler（调度器）—— "),r("strong",[e._v("调度任务的优先级")]),e._v("，高优任务优先进入"),r("strong",[e._v("Reconciler")])]),e._v(" "),r("li",[e._v("Reconciler（协调器）—— 负责找出变化的组件")]),e._v(" "),r("li",[e._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])]),e._v(" "),r("p",[e._v("可以看到，相较于 React15，React16 中新增了 "),r("strong",[e._v("Scheduler")]),e._v("(调度器)模块")]),e._v(" "),r("p",[e._v("在新的架构中，更新首先会被调度器处理，在调度器中会调度这些更新的优先级，更高优的更新会首先进入协调器，在本次更新的 "),r("code",[e._v("Reconcile")]),e._v(" 中正在执行 Diff 算法时，"),r("strong",[e._v("如果此时产生了更高优先级的更新，本次正在协调的更新会被中断，由于 "),r("code",[e._v("Scheduler")]),e._v(" 和 "),r("code",[e._v("Reconcile")]),e._v(" 都是在视图中完成的操作，因此即使更新中断，用户也不会看到更新不完整的视图")]),e._v("。当某次更新完成了 "),r("code",[e._v("Reconcile")]),e._v(" 中的工作时，协调器会通知渲染器，本次更新有哪些组件需要执行对应的视图操作（CRUD），当渲染器完成了它的工作，调度器又会开始新一轮的调度")]),e._v(" "),r("h3",{attrs:{id:"scheduler-调度器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#scheduler-调度器"}},[e._v("#")]),e._v(" Scheduler 调度器")]),e._v(" "),r("p",[r("strong",[e._v("我们知道如果我们的应用占用较长的 js 执行时间，比如超过了设备一帧的时间，那么设备的绘制就会出现卡顿的现象。")])]),e._v(" "),r("p",[e._v("Scheduler 主要的功能是"),r("strong",[e._v("时间切片和调度优先级")]),e._v("，react 在对比差异的时候会占用一定的 js 执行时间，Scheduler 内部借助 "),r("code",[e._v("MessageChannel")]),e._v(" 实现了在浏览器绘制之前指定一个时间片，如果 react 在指定时间内没对比完，Scheduler 就会强制交出执行权给浏览器")]),e._v(" "),r("p",[e._v("在 Scheduler 的实现核心是，判断浏览器是否有剩余时间作为任务中断的标准，在部分浏览器中以及实现了这个 API，"),r("code",[e._v("requestIdle Callback")]),e._v("，但是 React 并没有直接使用这个 API ，"),r("strong",[e._v("而是自行实现了一个功能更加完备的 requestIdleCallback 的 polyfill，也就是 Scheduler。")])]),e._v(" "),r("h3",{attrs:{id:"reconcile-协调器-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reconcile-协调器-2"}},[e._v("#")]),e._v(" Reconcile 协调器")]),e._v(" "),r("p",[e._v("在 React 15 的 "),r("code",[e._v("reconcile")]),e._v(" 协调器中，会通过递归的方式来处理虚拟 DOM ，这样导致 "),r("code",[e._v("Reconcile")]),e._v(" 过程无法被中断")]),e._v(" "),r("p",[e._v("React 16 推行 "),r("code",[e._v("Fiber reconciler")]),e._v(" 的主要目标是：")]),e._v(" "),r("ul",[r("li",[e._v("能够把可中断的任务切片处理。")]),e._v(" "),r("li",[e._v("能够调整优先级，重置并复用任务。")]),e._v(" "),r("li",[e._v("能够在父元素与子元素之间交错处理，以支持 React 中的布局。")]),e._v(" "),r("li",[e._v("能够在 "),r("code",[e._v("render()")]),e._v(" 中返回多个元素。")]),e._v(" "),r("li",[e._v("更好地支持错误边界。")])]),e._v(" "),r("p",[e._v("在 React 16 中将更新工作从递归变成了可以中断的循环过程，每次循环都会调用 shouldYield 判断当前是否有剩余时间")]),e._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("workLoopConcurrent")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 判断是否中断")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("while")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("shouldYield")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("performUnitOfWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("workInProgress"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("p",[r("strong",[e._v("那么 React 16 是如何解决更新中断时 DOM 渲染不完全的问题呢？")])]),e._v(" "),r("p",[e._v("在 React 16 中，Reconciler 与 Renderer "),r("strong",[e._v("不再是交替工作")]),e._v("。当 Scheduler 调度器将任务交给 Reconciler 后，Reconciler "),r("strong",[e._v("会为变化的 DOM 打上标记 effectTag")])]),e._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Placement "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*             */")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0b0000000000010")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Update "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*                */")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0b0000000000100")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" PlacementAndUpdate "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*    */")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0b0000000000110")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" Deletion "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*              */")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0b0000000001000")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("只有再所有组件都完成了 "),r("code",[e._v("Reconciler")]),e._v(" 的工作，才会统一交给 "),r("code",[e._v("Renderer")]),e._v(" 渲染器进行更新渲染")]),e._v(" "),r("h3",{attrs:{id:"renderer-渲染器-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#renderer-渲染器-2"}},[e._v("#")]),e._v(" Renderer 渲染器")]),e._v(" "),r("p",[e._v("Renderer 会根据 Reconciler 中为虚拟 DOM 打的 tag，在 commit 阶段"),r("strong",[e._v("同步执行")]),e._v("对应的 DOM 操作")]),e._v(" "),r("p",[e._v("同样也有多种不同的渲染器，和 React 15 中保持一致")]),e._v(" "),r("p",[e._v("以上就是 React 的设计理念以及新老架构的演变")]),e._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://react.iamkasong.com/preparation/oldConstructure.html#react15%E6%9E%B6%E6%9E%84",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 技术揭秘"),r("OutboundLink")],1),e._v(" -- React 15 架构")])])])}),[],!1,null,null,null);t.default=s.exports}}]);