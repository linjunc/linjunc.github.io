(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{448:function(e,v,_){e.exports=_.p+"assets/img/1.b11f8d35.png"},449:function(e,v,_){e.exports=_.p+"assets/img/2.9e8047b9.png"},491:function(e,v,_){"use strict";_.r(v);var t=_(65),r=Object(t.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("前面我们讲了 "),t("code",[e._v("render")]),e._v(" 阶段和 "),t("code",[e._v("commit")]),e._v(" 阶段的工作，讲了 "),t("code",[e._v("render")]),e._v(" 阶段中 Diff 算法的实现，现在我们已经对整体的流程有了一定的认识")]),e._v(" "),t("ul",[t("li",[e._v("在 "),t("code",[e._v("render")]),e._v(" 阶段的 "),t("code",[e._v("beginWork")]),e._v(" 阶段会创建子 "),t("code",[e._v("Fiber")]),e._v(" 节点，通过 Diff 算法，打上相应的 "),t("code",[e._v("effectTag")])]),e._v(" "),t("li",[e._v("在 "),t("code",[e._v("render")]),e._v(" 阶段的 "),t("code",[e._v("completeWork")]),e._v(" 阶段会根据 "),t("code",[e._v("Fiber")]),e._v(" 节点生成对应的 "),t("code",[e._v("DOM")]),e._v(" 节点，并连接子节点")]),e._v(" "),t("li",[e._v("在 "),t("code",[e._v("commit")]),e._v(" 阶段会对所有的 "),t("code",[e._v("effectTag")]),e._v(" 执行相应的 DOM 操作，更新视图")])]),e._v(" "),t("p",[e._v("在这些流程之前还有着，从"),t("strong",[e._v("触发状态更新到 "),t("code",[e._v("render")]),e._v(" 阶段")]),e._v("的过程，也就是我们本章需要学习的内容："),t("strong",[e._v("状态更新")])]),e._v(" "),t("p",[e._v("首先我们先了解一下什么是"),t("strong",[e._v("最小更新单元")])]),e._v(" "),t("h2",{attrs:{id:"最小更新单元"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最小更新单元"}},[e._v("#")]),e._v(" 最小更新单元")]),e._v(" "),t("p",[e._v("我们从实例来看，对于一个组件来说，如果想要触发更新，那么可以有以下这些情况")]),e._v(" "),t("ul",[t("li",[e._v("组件本身的 "),t("code",[e._v("state")]),e._v(" 发生改变")]),e._v(" "),t("li",[e._v("组件 "),t("code",[e._v("props")]),e._v(" 的改变，也就是父组件状态导致子组件更新")]),e._v(" "),t("li",[t("code",[e._v("context")]),e._v(" 改变，该组件消费的 "),t("code",[e._v("context")]),e._v(" 发生了更新")])]),e._v(" "),t("p",[e._v("但是归根结底，无论是哪种场景下触发的更新，最终的本质都是 "),t("code",[e._v("state")]),e._v(" 的变化导致的"),t("br"),e._v("\n对于 React 来说，能够触发 state 更新的基本都是"),t("strong",[e._v("在组件层面")]),e._v("上，毕竟 Fiber 没有办法实现自我更新，只能依赖组件进行 "),t("code",[e._v("state")]),e._v(" 更想你"),t("br"),e._v("\n因此，我们可以认为 "),t("strong",[e._v("最小的更新单元是组件，更新源自于 state 的变化")])]),e._v(" "),t("p",[t("strong",[e._v("那么如何触发更新呢？")])]),e._v(" "),t("h2",{attrs:{id:"触发更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发更新"}},[e._v("#")]),e._v(" 触发更新")]),e._v(" "),t("p",[e._v("竟然组件是最小的更新单元，那么我们可以知道，触发更新可以分为")]),e._v(" "),t("ul",[t("li",[e._v("类组件的 "),t("code",[e._v("setState")]),e._v(" 状态更新")]),e._v(" "),t("li",[e._v("函数组件的 "),t("code",[e._v("useState")]),e._v(" 状态更新")])]),e._v(" "),t("p",[t("strong",[e._v("那么，状态更新都会触发哪些流程呢？")])]),e._v(" "),t("h2",{attrs:{id:"创建-update-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建-update-对象"}},[e._v("#")]),e._v(" 创建 Update 对象")]),e._v(" "),t("p",[e._v("首先，每次状态更新都会创建一个保存更新状态内容的对象，也就是 Update 对象，保存在 updateQueue 链表中，记录当前 Fiber 节点收集到的更新。在 "),t("code",[e._v("render")]),e._v(" 阶段的 "),t("code",[e._v("beginWork")]),e._v(" 中会根据 "),t("code",[e._v("Update")]),e._v(" 对象来计算新的 "),t("code",[e._v("state")]),t("br"),t("img",{attrs:{src:_(448),alt:"image.png"}}),e._v(")"),t("br"),e._v("这个 Update 会被保存在一个环状链表中，接下来会调用 "),t("code",[e._v("scheduleUpdateOnFiber")]),e._v(" 方法，来调度这个 Update")]),e._v(" "),t("h2",{attrs:{id:"标记-rootfiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-rootfiber"}},[e._v("#")]),e._v(" 标记 RootFiber")]),e._v(" "),t("p",[e._v("我们知道 "),t("code",[e._v("render")]),e._v(" 阶段是从 "),t("code",[e._v("rootFiber")]),e._v(" 开始向下遍历，因此我们需要在 "),t("code",[e._v("render")]),e._v(" 阶段开始之前，让 "),t("code",[e._v("rootFiber")]),e._v(" 知道本次调度的相关信息。"),t("br"),e._v("因此我们需要从当前触发更新的节点对应的 Fiber "),t("strong",[e._v("一直遍历到应用的根节点 rootFiber")]),e._v("，并通知沿途的 Fiber，你有子孙节点被更新了，打上"),t("strong",[e._v("本次触发更新的优先级标记")]),e._v("，并返回 rootFiber"),t("br"),e._v("这一步叫做 "),t("code",[e._v("markUpdateLaneFromFiberToRoot")])]),e._v(" "),t("h2",{attrs:{id:"调度更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度更新"}},[e._v("#")]),e._v(" 调度更新")]),e._v(" "),t("p",[e._v("经过了上面的处理，我们已经获取到了 "),t("code",[e._v("RootFiber")]),e._v("，并且在这个 Fiber 上同时标记了子树中的 Update"),t("br"),e._v("接下来，需要通知 Scheduler 调度器来根据更新的优先级，以及任务的类型，来发起异步或是同步的更新调度，这一步调用的是 "),t("code",[e._v("ensureRootIsScheduled")]),e._v(" 方法")]),e._v(" "),t("ul",[t("li",[e._v("对于 legacy 模式下，最后执行的是 "),t("code",[e._v("performSyncWorkOnRoot")]),e._v(" 方法")]),e._v(" "),t("li",[e._v("对于 concurrent 模式，最后执行的是  "),t("code",[e._v("performConcurrentWorkOnRoot")]),e._v(" 方法")])]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("当调度的回调函数被执行，会进入组件的 "),t("code",[e._v("render")]),e._v(" 阶段")]),e._v(" "),t("ul",[t("li",[e._v("在 "),t("code",[e._v("render")]),e._v(" 阶段的 "),t("code",[e._v("reconcile")]),e._v(" 也就是 diff 算法中，会根据 "),t("code",[e._v("Update")]),e._v(" 对象，返回对应的 "),t("code",[e._v("state")]),e._v("，根据 "),t("code",[e._v("state")]),e._v(" 判断本次是否需要更新视图，如果需要更新视图就会被标记为 "),t("code",[e._v("effectTag")])]),e._v(" "),t("li",[e._v("在 "),t("code",[e._v("commit")]),e._v(" 阶段，标记了 "),t("code",[e._v("effectTag")]),e._v(" 的 "),t("code",[e._v("Fiber")]),e._v("，就会执行对应的视图更新")])]),e._v(" "),t("p",[t("img",{attrs:{src:_(449),alt:"image.png"}})])])}),[],!1,null,null,null);v.default=r.exports}}]);