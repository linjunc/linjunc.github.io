import{_ as s,c as a,o as n,V as l}from"./chunks/framework.3d11d069.js";const A=JSON.parse('{"title":"Recoil 理念和用法","description":"","frontmatter":{},"headers":[],"relativePath":"pages/summary/recoil.md","filePath":"pages/summary/recoil.md","lastUpdated":1688305715000}'),o={name:"pages/summary/recoil.md"},p=l(`<h1 id="recoil-理念和用法" tabindex="-1">Recoil 理念和用法 <a class="header-anchor" href="#recoil-理念和用法" aria-label="Permalink to &quot;Recoil 理念和用法&quot;">​</a></h1><h2 id="react-状态管理" tabindex="-1">React 状态管理 <a class="header-anchor" href="#react-状态管理" aria-label="Permalink to &quot;React 状态管理&quot;">​</a></h2><p>我们在实现组件间交互时，常常会需要使用状态来控制，例如：通过按钮控制弹窗展示</p><p>我们需要定义一个 <code>isOpen</code> 的状态，通过这个状态来决定显示和隐藏。</p><p>我们可以通过 props 的方式，将状态值分发下去，同时将 dispatch 方法也进行透传。这样我们可以在子组件中更改父组件的状态，从而控制兄弟组件的渲染。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Page </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">isOpen</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setIsOpen</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> &lt;&gt;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">ButtonComponent</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setIsOpen</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">setIsOpen</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">  </span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Dialog</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isOpen</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">isOpen</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;/&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>当项目逐渐复杂，我们的状态需要被越来越多的组件使用，按照上面的方式，我们需要不断的把状态往上提，再通过 props 透传下来。</p><p>到最后，所有的状态都被存在父节点上，根节点上也可能会有大量的状态，全部通过 props 传递，这样会导致很多问题</p><ul><li>状态需要层层传递，组件间通信困难。</li><li>状态变化，引起根组件重渲染，出现性能问题，当然可以用 memo，但是也增加了 memo 的工作量</li><li>状态会变得十分混乱，可维护性降低</li><li>组件和根组件耦合严重，难以拆分和复用</li></ul><p>开始用一些状态管理工具，例如官方的 useContext，第三方状态库 Redux、Mobx</p><h3 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h3><p>我们可以通过 useContext 和 useReducer hook 来实现跨层级状态传递。</p><p>通过 createContext 创建 context 上下文，通过 provider 来提供状态。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ThemeContext </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createContext</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyApp</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">ThemeContext</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Provider</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dark</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Form</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#A6ACCD;">ThemeContext</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Provider</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>通过 useContext hook 可以在组件中读取和订阅 context</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useContext</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Button</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">theme</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useContext</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">ThemeContext</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span></code></pre></div><p>useContext 实现状态管理的方式存在着一些问题</p><ul><li>useContext 中的状态变化，所有使用这个 context 的组件都会重新渲染，这会导致一些不必要的重渲染，造成性能问题，同时我们也没有很好的性能优化手段</li><li>我们需要规划好哪些状态存放在哪个 context 内，这样导致状态分散在多个不同的 context 中，难以管理和维护</li><li>React 18 下存在并发更新冲突的问题？</li></ul><p>随之，我们开始尝试第三方状态管理库</p><h3 id="redux" tabindex="-1">Redux <a class="header-anchor" href="#redux" aria-label="Permalink to &quot;Redux&quot;">​</a></h3><p>Redux 开始提倡了 immutable 的方式来实现数据的管理。</p><p>正如 Redux 官网说的，Redux 让你开发出 <strong>行为稳定可预测</strong> 的应用</p><p>这也是 Redux 的核心吧，通过 dispatch action 的方式来触发状态变化，通过 reducer 来处理状态变化，reducer 必须是一个纯函数，相同的输入要用相同的输出，不产生副作用。</p><p>Redux 可以分为 3 个重要的部分</p><p><strong>Store</strong></p><p>使用 Redux 提供的 createStore 函数传入一个 reducer 创建 Store。Store 对 object 的内部实现是通过事件订阅模式来关联组件和状态的变化。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createStore</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">redux</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> rootReducer </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./reducers</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// rootReducer 是多个 reducer 的组合</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> store </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createStore</span><span style="color:#A6ACCD;">(rootReducer)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p><strong>Action</strong></p><p>Action 就是前面说的行为。表示执行的是什么操作，通过 type 表示操作，其他属性来携带信息</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> incrementAction </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">INCREMENT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">payload</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// action 创建函数</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">payload</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">INCREMENT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">payload</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><strong>Reducer</strong></p><p>Reducer 是 action 的执行者，生成新的状态并返回。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">counterReducer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">action</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">INCREMENT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>当派发一个 Action 时，Store 会调用 Reducer 生成新的状态，并基于订阅者模式通知关联组件更新，触发组件重新渲染。</p><p>Redux 用的很难受，它规定我们必须要按照这样的范式来编写代码，每个状态变化都要对应一个行为出现，很难受</p><p>后来又有了 Mobx</p><h3 id="mobx" tabindex="-1">Mobx <a class="header-anchor" href="#mobx" aria-label="Permalink to &quot;Mobx&quot;">​</a></h3><p>Mobx 是响应式状态管理库，感觉和 Vue 的响应式原理有点像？</p><p>Mobx 还是需要通过编写数据模型，通过响应式的数据模型来驱动组件重新渲染。</p><p>Mobx 的缺点还是需要定义数据模型，不过比 Mobx 的方式要简单很多了，而且还是响应式的。</p><p>现在也出现了越来越多的第三方状态库，zustand、jotai、recoil 好多库</p><p>这里主要讲讲 recoil，因为工作中需要接触到，正好学习一下！</p><h2 id="recoil-基础用法" tabindex="-1">Recoil 基础用法 <a class="header-anchor" href="#recoil-基础用法" aria-label="Permalink to &quot;Recoil 基础用法&quot;">​</a></h2><p>Recoil 官网说的很简单，说实话很难轻易的看明白。因为 Recoil 引入了一些新的名词，atom、selector 都会有一点难理解吧。下面用的理解解释一下</p><p>Recoil 和其他状态管理库一样，也是将所有的变量存放在顶层数据集合中，但是 Recoil 可以做到对每个变量进行拆分和组合，这也就是 Recoil 中的原子性吧。</p><p>原子是化学反应中最小且不可再分割的元素。但是在物理上还可以分成电子和原子核，因此可以把原子理解成足够小，不可分割的最小单位</p><p>下面通过官网的例子来写</p><h3 id="recoil-特性" tabindex="-1">Recoil 特性 <a class="header-anchor" href="#recoil-特性" aria-label="Permalink to &quot;Recoil 特性&quot;">​</a></h3><p>首先和需要用特有的标签包裹 App 组件，用于创建一个状态管理对象，对于子组件不会感知到这个对象的存在。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">RecoilRoot</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">recoil</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">RecoilRoot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">RecoilRoot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>然后在组件 A 中，使用 Recoil 提供的函数来定义和管理数据</p><p>用一个字符串类型的 key，作为变量的 ID，然后得到变量 textState 的引用</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> textState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">atom</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">textState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// unique ID (with respect to other atoms/selectors)</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// default value (aka initial value)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>在组件 B 中，用 Recoil 提供的钩子函数，传递 textState 引用对象为参数，获取到操作变量的不同权限</p><ol><li>获取读和写的权限</li><li>只获取读的权限</li><li>只获取写的权限</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">text</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setText</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRecoilState</span><span style="color:#A6ACCD;">(textState)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> text </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRecoilValue</span><span style="color:#A6ACCD;">(textState)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>都有不同的钩子来获取，这样在组件 A 和组件 B，各自都有对变量 textState 的读写能力，那么只要有一方修改了值，Recoil 都会自动通知另一方，并且重新渲染。</p><p>Recoil 可以让我们非常方便的定义全局变量，唯一的心智负担是需要全局唯一的标识 id，用来定位每一条数据。</p><h3 id="拆分和组合" tabindex="-1">拆分和组合 <a class="header-anchor" href="#拆分和组合" aria-label="Permalink to &quot;拆分和组合&quot;">​</a></h3><p><strong>拆分的例子</strong></p><p>假设通过 Recoil 定义了一个 object 类型的变量 obj，结构为</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">a</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">arr</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">string</span><span style="color:#F07178;">[]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>假设有个组件 A，只关心 obj.arr 值的变化，按照传统的状态管理思路，一定需要将 obj 完整引入，然后通过 obj.arr 这种形式去找到 arr 。</p><p>但是 Recoil 中可以只引入 arr，也就是对于组件 A 而言，它并不关心 obj 的存在。</p><p><strong>类似的组合例子</strong></p><p>假设有两个变量 obj1，obj2</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">width</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">height</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">x</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">number</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">y</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">number</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>假设有组件 B 需要获取 obj1 和 obj2 水平距离，基于之前，我们需要引入 obj1，obj2，然后进行计算得到间隔</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> offsetX </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> objB</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> objA</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> objA</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">width</span></span></code></pre></div><p>但是 Recoil 可以将计算进行剥离，派生出新的状态 offsetX，组件 B 无需关心 obj1，obj2，只需引入 offsetX。</p><p>通过 Recoil 提供的能力，我们可以对状态进行拆分和组合，减少定义更多的原始状态。</p><h3 id="atom-selector" tabindex="-1">Atom / Selector <a class="header-anchor" href="#atom-selector" aria-label="Permalink to &quot;Atom / Selector&quot;">​</a></h3><p>相信到这里你对拆分和组合有了一定的了解，可以开始看这两个最重要的概念了。</p><h4 id="atom" tabindex="-1">atom <a class="header-anchor" href="#atom" aria-label="Permalink to &quot;atom&quot;">​</a></h4><p>atom 用来定义变量，传递 key 唯一 id 和 default 默认值，会返回一个 RecoilState 实例，注意返回的这个 RecoilState 是引用。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">atom</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxxxxxx</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>这样，我们通过 atom 就向全局添加了 id 为 a 的变量</p><p>在实际项目中，为了防止 key 被重复定义，我们可以通过建立 keyMap 对象，所有的 key 都从这里暴露出去，方便统一管理</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> keyMap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>也可以将原子变量写在一起，统一集体导出。这样可以方便引用不同的 atom。</p><h4 id="selector" tabindex="-1">selector <a class="header-anchor" href="#selector" aria-label="Permalink to &quot;selector&quot;">​</a></h4><p>selector 官方的定义是：接收原子数据或其他选项作为数据输入源的纯函数。</p><p>前面讲拆分和组合就是为了为 selector 铺垫，可以通过 selector 将原子数据组合和拆分出新的数据</p><p>首先我们先用 atom 创建一个变量，记录一个字符串的值</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> textState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">atom</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">textState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>再使用 selector 派生出一个用于表示字符串长度的变量</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> countState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">selector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">charCountState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">textState</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">//获取到字符串</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">text</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//返回字符串的长度</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>通过传递 get 方法来定义 state 的获取方式，get 函数会传入 get 参数，这两个不一样，get 参数可以用来获取 atom 的值。</p><p>selector 看起来真的很好用，还可以派生出同时依赖多个原子数据状态的 state</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> xxxState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">selector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxxState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">aa</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">aaState</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bb</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bbState</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">xxxxx</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>selector 也是纯函数，也有点像 Redux 的那种，但是大不相同。selector 带来了很多的好处，</p><ul><li>无需修改对应的组件，就能将它们本地的 state 用派生数据替换。</li><li>无需修改对应的组件，就能将派生数据在同步与异步间切换。</li></ul><h3 id="recoil-hooks" tabindex="-1">Recoil Hooks <a class="header-anchor" href="#recoil-hooks" aria-label="Permalink to &quot;Recoil Hooks&quot;">​</a></h3><h4 id="userecoilstate" tabindex="-1">useRecoilState <a class="header-anchor" href="#userecoilstate" aria-label="Permalink to &quot;useRecoilState&quot;">​</a></h4><p>用户获取变量的读写权限</p><p>用法和 useState 一样，都是 <code>state + dispatch</code> 的形式。区别在于需要传入的参数是 RecoilState 实例</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> textState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">atom</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">textState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">text</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setText</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRecoilState</span><span style="color:#A6ACCD;">(textState)</span></span></code></pre></div><h4 id="userecoilvalue、usesetrecoilstate" tabindex="-1">useRecoilValue、useSetRecoilState <a class="header-anchor" href="#userecoilvalue、usesetrecoilstate" aria-label="Permalink to &quot;useRecoilValue、useSetRecoilState&quot;">​</a></h4><p><code>useRecoilValue</code> 返回给定 RecoilState 的值，这个 hook 只获取值，<code>useSetRecoilState</code> 得到修改变量的方法</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> text </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRecoilValue</span><span style="color:#A6ACCD;">(textState)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> setText </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useSetRecoilState</span><span style="color:#A6ACCD;">(textState)</span></span></code></pre></div><p><code>useRecoilValue</code> 和 <code>useRecoilState</code> 还是存在着不一样的地方的</p><p><code>useRecoilValue</code> 可以用来获取只读 state 和可写 state 的值。Atom 是可写 state，而 selector 可以是只读，也可以是可写的</p><p>但是 <code>useRecoilState</code> 不行，<code>useRecoilState</code> 传入的 state 参数必须是 可写的 selector，或者是 atom</p><p><strong>可写的 selector 是指，同时定义了 get 和 set 函数的。而只读是只有一个 get 函数</strong></p><h4 id="useresetrecoilstate" tabindex="-1">useResetRecoilState <a class="header-anchor" href="#useresetrecoilstate" aria-label="Permalink to &quot;useResetRecoilState&quot;">​</a></h4><p>返回一个函数，用来把给定 state 重置为其初始值。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> textState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">atom</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">textState</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">default</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> reset </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useResetRecoilState</span><span style="color:#A6ACCD;">(textState)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">reset</span><span style="color:#A6ACCD;">()</span></span></code></pre></div><p>reset 触发后，textState 对应的变量恢复成默认值。</p><p>还有几个其他的钩子，处理异步数据等，这里先不看了～</p><h2 id="recoil-实现原理" tabindex="-1">Recoil 实现原理 <a class="header-anchor" href="#recoil-实现原理" aria-label="Permalink to &quot;Recoil 实现原理&quot;">​</a></h2><blockquote><p>展示不从源码角度分析</p></blockquote><p>Recoil 基于发布订阅模式来实现状态更新，在调用取值 hook 读取 atom 时，组件会隐式的订阅该 atom，任何 atom 变化都会引起组件的重新渲染。</p><p>也就是说，在读取 atom 的地方，就会开启一个 subscribe，在 update 时，会进行 emit</p>`,113),e=[p];function t(c,r,y,D,F,i){return n(),a("div",null,e)}const d=s(o,[["render",t]]);export{A as __pageData,d as default};
