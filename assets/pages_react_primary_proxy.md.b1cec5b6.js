import{_ as s,c as a,o,V as p}from"./chunks/framework.3d11d069.js";const g=JSON.parse('{"title":"React 入门学习（七）-- 脚手架配置代理","description":"React 本身只关注于页面，并不包含发送 Ajax 请求的代码，所以一般都是集成第三方的包，或者自己封装的 自己封装的话，比较麻烦","frontmatter":{"title":"React 入门学习（七）-- 脚手架配置代理","date":"2021-08-27T11:52:42.000Z","id":1635581982,"tags":["react","脚手架"],"categories":["React入门学习"],"keywords":"react,跨域,代理,脚手架","description":"React 本身只关注于页面，并不包含发送 Ajax 请求的代码，所以一般都是集成第三方的包，或者自己封装的 自己封装的话，比较麻烦"},"headers":[],"relativePath":"pages/react/primary/proxy.md","filePath":"pages/react/primary/proxy.md","lastUpdated":1692936659000}'),n={name:"pages/react/primary/proxy.md"},l=p(`<p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/React%20-%20%E4%BB%A3%E7%90%86.gif" alt="React - 代理" data-fancybox="gallery"></p><blockquote><p>📢 大家好，我是小丞同学，一名<div color="#2e86de"><strong>准大二的前端爱好者</strong></div></p><p>📢 这篇文章是学习 React 中<strong>脚手架配置代理</strong>的学习笔记</p><p>📢 非常感谢你的阅读，不对的地方欢迎指正 🙏</p><p>📢 <div color="#f368e0"><strong>愿你忠于自己，热爱生活</strong></div></p></blockquote><h1 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h1><p>React 本身只关注于页面，并不包含发送 Ajax 请求的代码，所以一般都是集成第三方的包，或者自己封装的</p><p>自己封装的话，比较麻烦，而且也可能考虑不全</p><p>常用的有两个库，一个是JQuery，一个是 axios</p><ol><li>JQuery 这个比较重，因为 Ajax 服务也只是它这个库里的一小块功能，它主要做的还是 DOM 操作，而这不利于 React ，不推荐使用</li><li>axios 这个就比较轻，而且采用 Promise 风格，代码的逻辑会相对清晰，<strong>推荐使用</strong></li></ol><p>因此我们这里采用 axios 来发送客户端请求</p><p>以前，我们在发送请求的时候，经常会遇到一个很重要的问题：跨域！</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210827091119837.png" alt="image-20210827091119837" data-fancybox="gallery"></p><p>在我以前的学习中，基本上都需要操作后端服务器代码才能解决跨域的问题，配置请求头，利用 script，这些都需要后端服务器的配合，因此我们前端需要自己解决这个问题的话，就需要这个技术了：<strong>代理</strong>。</p><p>在说代理之前，先谈谈为什么会出现跨域？</p><p>这个应该是源于浏览器的同源策略。所谓同源（即指在同一个域）就是两个页面具有相同的协议，主机和端口号， 当一个请求 URL 的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面 URL 不同即为跨域 。</p><p>也就是说 <code>xxx:3000</code>和 <code>xxx:4000</code> 会有跨域问题，<code>xxx:3000</code> 与 <code>abc:3000</code> 有跨域问题</p><p>那接下来我们采用<strong>配置代理</strong>的方式去解决这个问题</p><blockquote><p>关于跨域的问题解决方案，在之后的文章会有总结 ~</p></blockquote><h2 id="_1-全局代理" tabindex="-1">1. 全局代理 <a class="header-anchor" href="#_1-全局代理" aria-label="Permalink to &quot;1. 全局代理&quot;">​</a></h2><p>第一种方法，我把它叫做全局代理，因为它直接将代理配置在了配置文件 <code>package.json</code> 中</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">proxy</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://localhost:5000</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// &quot;proxy&quot;:&quot;请求的地址&quot;</span></span></code></pre></div><p>这样配置代理时，首先会在抓原请求地址上访问，如果访问不到文件，就会转发到这里配置的地址上去请求</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/%E8%BD%AC%E5%8F%91.png" alt="转发" data-fancybox="gallery"></p><p>我们需要做的就是在我们的请求代码中，将请求的地址改到转发的地址，即可</p><p>但是这样会有一些问题，它会先向我们请求的地址，也就是这里的 <code>3000</code> 端口下请求数据，如果在 <code>3000</code> 端口中存在我们需要访问的文件，会直接返回，<strong>不会再去转发</strong></p><p>因此这就会出现问题，同时因为这种方式采用的是全局配置的关系，导致<strong>只能转发到一个地址</strong>，不能配置多个代理</p><h2 id="_2-单独配置" tabindex="-1">2. 单独配置 <a class="header-anchor" href="#_2-单独配置" aria-label="Permalink to &quot;2. 单独配置&quot;">​</a></h2><p>这也是我自己起的名字，这种配置方式，可以给多个请求配置代理，非常不错</p><p>它的工作原理和全局配置是一样的，但是写法不同</p><p><strong>首先</strong>我们需要在 <code>src</code> 目录下，创建代理配置文件 <code>setupProxy.js</code></p><p>注意：这个文件只能叫这个名字，脚手架在启动的时候，会自动执行这些文件</p><p><strong>第二步</strong></p><p>配置具体的代理规则，我们大致讲讲这些是什么意思</p><ol><li><p>首先我们需要引入这个 <code>http-proxy-middleware</code> 中间件，然后需要导出一个对象，这里建议使用函数，使用对象的话兼容性不大好</p></li><li><p>然后我们需要在 <code>app.use</code> 中配置，我们的代理规则，首先 <code>proxy</code> 接收的第一个参数是需要转发的请求，我的理解是一个标志的作用，当有这个标志的时候，预示着我们需要采用代理，例如 <code>/api1</code> ，我们就需要在我们 <code>axios</code> 的请求路径中，加上 <code>/api1</code> ，这样所有添加了 <code>/api1</code> 前缀的请求都会转发到这</p></li><li><p>第二个参数接受的是一个对象，用于配置代理。</p><ul><li><code>target</code> 属性用于配置转发目标地址，也就是我们数据的地址</li><li><code>changeOrigin</code> 属性用于控制服务器收到的请求头中 <code>host</code> 字段，可以理解为一个伪装效果，为 <code>true</code> 时，收到的 <code>host</code> 就为请求数据的地址</li><li><code>pathRewrite</code> 属性用于去除请求前缀，因为我们通过代理请求时，需要在请求地址前添加一个标志，但是实际的地址是不存在这个标志的，所以我们<strong>一定要去除</strong>这个前缀，这里采用的有点类似于正则替换的方式</li></ul></li></ol><p>配置一个代理的完整代码如下</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http-proxy-middleware</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">app</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">proxy</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/api1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">      target</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http://localhost:5000</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//配置转发目标地址</span></span>
<span class="line"><span style="color:#F07178;">      changeOrigin</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//控制服务器接收到的请求头中host字段的值</span></span>
<span class="line"><span style="color:#F07178;">      pathRewrite</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">^/api1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//去除请求前缀址(必须配置)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><hr><p>关于脚手架配置代理的内容就到这里啦！</p><blockquote><p>非常感谢您的阅读，欢迎提出你的意见，有什么问题欢迎指出，谢谢！🎈</p></blockquote>`,37),e=[l];function t(c,r,i,y,d,F){return o(),a("div",null,e)}const u=s(n,[["render",t]]);export{g as __pageData,u as default};
