import{_ as e,c as o,o as t,U as d}from"./chunks/framework.4d5e0f31.js";const x=JSON.parse('{"title":"HTTP 状态码","description":"","frontmatter":{},"headers":[],"relativePath":"pages/network/statuscode.md","lastUpdated":1686997184000}'),c={name:"pages/network/statuscode.md"},l=d('<h1 id="http-状态码" tabindex="-1">HTTP 状态码 <a class="header-anchor" href="#http-状态码" aria-label="Permalink to &quot;HTTP 状态码&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>完整可以看 MDN： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noreferrer">状态码</a></p></div><h2 id="状态码类别" tabindex="-1">状态码类别 <a class="header-anchor" href="#状态码类别" aria-label="Permalink to &quot;状态码类别&quot;">​</a></h2><table><thead><tr><th><code>1xx</code></th><th style="text-align:center;">信息性状态码</th><th style="text-align:center;">接收的请求正在处理</th></tr></thead><tbody><tr><td><code>2xx</code></td><td style="text-align:center;">成功状态码</td><td style="text-align:center;">请求正常处理完毕</td></tr><tr><td><code>3xx</code></td><td style="text-align:center;">重定向状态码</td><td style="text-align:center;">需要进行附加操作才能完成请求</td></tr><tr><td><code>4xx</code></td><td style="text-align:center;">客户端错误状态码</td><td style="text-align:center;">服务器无法处理请求</td></tr><tr><td><code>5xx</code></td><td style="text-align:center;">服务端错误状态码</td><td style="text-align:center;">服务器处理请求出错</td></tr></tbody></table><ol><li><p>1xx：信息性状态码，接收的请求正在处理</p><ul><li><code>100</code>，这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它，服务器必须在请求完成后向客户端发送一个最终响应</li><li><code>101</code>：Switching Protocols，在升级 Websocket 的时候，如果服务端同意变更协议，就会返回这个状态码</li></ul></li><li><p>2xx：成功请求，请求正常处理完毕</p><ul><li><code>200</code>：OK 表示从客户端发的请求服务端正确处理了</li><li><code>201</code>: Created 请求成功并且服务器创建了新的资源，这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</li><li><code>204</code>：<code>No content</code> 服务器成功处理了请求，但是<strong>没有返回任何内容</strong></li><li><code>205</code>：<code>reset content</code> 请求成功 并且要求客户端重置视图</li><li><code>206</code> <code>partial content</code> 进行范围请求，使用 Range 字段的时候，会返回这个状态码进行响应</li></ul></li><li><p><code>3xx</code> 重定向</p><ul><li><code>301</code>: 永久性重定向 请求的资源已经<strong>永久移动到新的位置</strong>，搜索引擎会记录 301 的 location 指向的地址</li><li><code>302</code>：临时性重定向 表示请求的资源已经<strong>临时移动到新的位置</strong>，未登录的用户重定向到登录页面，登录成功后，再重定向到之前的页面</li><li><code>303</code>: 重定向 资源存在另一个<code>URL</code> 应该用<code>get</code>方法获取资源(一般用于上传文件后，返回的重定向到消息确认页面或者上传进度页面)</li><li><code>304</code>: <code>not modified</code> 客户端可以通过本地缓存来更新，所请求的资源未修改。</li><li><code>307</code>: 临时重定向 但是与 303 不同的是期望客户端<strong>保持请求方法不变向新的地址发出请求</strong><ul><li>（一般浏览器会自动由 post -&gt; get 但是307不会 还是 post -&gt; post）</li></ul></li></ul></li><li><p><code>4xx</code> 客户端错误</p><ul><li><code>400</code> <code>bad request</code> 请求报文语法错误或格式不对</li><li><code>401</code> <code>unauthorized</code> 表示请求需要<strong>身份验证</strong></li><li><code>403</code> <code>forbidden</code> 请求资源被服务器<strong>拒绝</strong></li><li><code>404</code> <code>not found</code> 在服务器未找到请求的资源</li><li><code>405</code> <code>method not allow</code> 服务器禁止使用这种方法</li></ul></li><li><p><code>5xx</code> 服务器错误</p><ul><li><code>500</code>: <code>internal server error</code> 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</li><li><code>501</code>: <code>not implemented</code> 服务器不支持当前请求所需要的某个功能</li><li><code>502</code>: <code>bad gateway</code> （错误网关）服务器作为网关或代理，从上游服务器收到无效响应</li><li><code>503</code>: <code>service unavailable</code> 服务器暂时在<strong>超负载</strong>或停机维护(<code>nginx</code>限速)</li><li><code>504</code>: <code>gateway timeout</code> 网关或代理服务器无法在规定时间获得响应(代码执行时间超过 或 死循环)</li></ul></li></ol><h2 id="同样是重定向-302-303-307有什么区别" tabindex="-1">同样是重定向 <code>302</code> <code>303</code> <code>307</code>有什么区别 <a class="header-anchor" href="#同样是重定向-302-303-307有什么区别" aria-label="Permalink to &quot;同样是重定向 `302` `303` `307`有什么区别&quot;">​</a></h2><p><code>302</code> 是 <code>http1.0</code> 的协议状态码，在 <code>HTTP1.1</code> 后为了细化 <code>302</code>，又分出了 <code>303</code> 和 <code>307</code></p><p>这三个状态码都是临时重定向，但是有一些区别</p><p>303 重定向是对 POST 请求的安全处理，客户端使用 POST 来请求资源时，如果资源需要进行重定向，则服务端需要返回一个 303 状态码，告诉客户端使用 GET 来获取资源，以避免数据安全的问题</p><p>303 和 307 的区别在于 303 期望客户端<strong>使用 GET 方法来获取资源</strong>，而 307 期望客户端<strong>保持原有的请求方法</strong></p><h2 id="浏览器会缓存-301-页面吗-如何清除缓存" tabindex="-1">浏览器会缓存 301 页面吗？如何清除缓存？ <a class="header-anchor" href="#浏览器会缓存-301-页面吗-如何清除缓存" aria-label="Permalink to &quot;浏览器会缓存 301 页面吗？如何清除缓存？&quot;">​</a></h2><p>假设不小心将初始页面永久重定向到 301 页面，想要临时重定向到 302 页面。</p><p>会发现 浏览器会缓存 301 页面，即使是临时重定向到 302 页面，浏览器也会缓存 301 页面。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>如果我们没有提供明确的缓存头，浏览器就会默认永久缓存 301 响应，因为 301 是永久重定向的意思。</strong></p></div><p><strong>如何清除 301 重定向</strong></p><ul><li>控制台禁用缓存</li><li>清楚历史记录</li><li>Network -&gt; Disable Cache</li><li>强刷浏览器</li></ul><p>或者可以在服务端设置 <code>Cache-Control: no-cache</code></p><h2 id="介绍一下-304-的过程" tabindex="-1">介绍一下 304 的过程 <a class="header-anchor" href="#介绍一下-304-的过程" aria-label="Permalink to &quot;介绍一下 304 的过程&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>浏览器请求资源时，首先命中资源的 <code>Expires</code> 和 <code>Cache-Control</code>，<code>Expires</code> 过期时间受限于本地时间，如果修改了本地时间，可能会导致缓存失败，可以通过 <code>Cache-Control: max-age=</code> 来指定最大的生命周期时间，<strong>状态返回 200</strong>，但不会请求数据，在浏览器中能看到 <code>from cache</code> 的字段</p><p>如果强缓存失效，会进入协商缓存阶段，首先验证 <code>Etag</code> 可以保证每一个资源是唯一的，资源变化都会导致 <code>ETag</code> 变化。服务端根据客户端发送的 <code>If-None-Match</code> 来判断是否命中缓存</p><p>到了协商缓存 <code>Last-Modified</code> 阶段，客户端第一次请求资源时，服务端返回的 header 中会加上 <code>Last-Modified</code>，<code>Last-Modified</code> 是一个时间标识该资源的最后修改时间，再次请求该资源的时候，请求头会添加 <code>If-Modified-Since</code>，值为之前缓存的值，服务端根据这个时间来判断是否和资源的最后修改时间命中，来决定是否命中缓存。</p></div><h2 id="http-状态码-304-越多越好吗" tabindex="-1">HTTP 状态码 304 越多越好吗？ <a class="header-anchor" href="#http-状态码-304-越多越好吗" aria-label="Permalink to &quot;HTTP 状态码 304 越多越好吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>并不是绝对的，要根据实际场景来看，在一些场景下，为了避免被客户端缓存，服务器需要返回 200 响应状态码来确保客户端拿到的是最新的数据， 304 状态码就不适用了；在另一些场景下，需要加速加载速度，减少网络带宽消耗，就可以使用 304 状态码来避免重复加载资源。 对于一些静态资源，例如图片、CSS、JS 文件等，由于很少更改，因此适合使用 304 状态码缓存，这可以减少带宽消耗，更快地加载资源，提升网站的性能和用户体验。</p></div><p>304 是为了提高网站的访问速度的，减轻服务器的负担，对指定页面进行缓存。</p><p>但是搜索引擎更青睐更新频率高的网站，通过特定的时间对网站抓取返回的状态码来调节网站抓去频次，如果一直是 304，抓取次数就会降低，相反，如果更新快，回访的率就会高。</p><p>但如果返回 200，即使网页内容未发生变化，搜索引擎仍然会重新抓取并索引网页。同时被爬虫的次数的增多也会给服务器造成压力。但也有助于优化搜索引擎的爬虫抓取。</p><p>当搜索引擎的爬虫请求某个网页时，如果该网页没有被修改，服务器会返回 304 状态码，爬虫就会直接从缓存中读取该页面，而不会重新抓取和索引。这可以降低服务器的负担，减少搜索引擎爬虫的抓取频率，有助于优化搜索引擎爬虫的抓取结果和网站的排名。</p>',25),i=[l];function a(r,s,n,p,h,g){return t(),o("div",null,i)}const b=e(c,[["render",a]]);export{x as __pageData,b as default};
