import{_ as e,c as a,o as s,U as o}from"./chunks/framework.4d5e0f31.js";const n="/assets/idea.efe71de7.png",t="/assets/9.ce1a55c2.jpeg",u=JSON.parse('{"title":"React 设计理念","description":"","frontmatter":{},"headers":[],"relativePath":"pages/react/hard/fiberidea.md","lastUpdated":1687081313000}'),l={name:"pages/react/hard/fiberidea.md"},r=o('<h1 id="react-设计理念" tabindex="-1">React 设计理念 <a class="header-anchor" href="#react-设计理念" aria-label="Permalink to &quot;React 设计理念&quot;">​</a></h1><p><img src="'+n+'" alt="image.png" data-fancybox="gallery"></p><p>React 是用 JavaScript 构建<strong>快速响应</strong>的大型 Web 应用程序的首选方式。</p><p>设计理念：快速响应</p><p>制约瓶颈：CPU 与 IO 瓶颈</p><ul><li>当遇到大计算量的操作或者设备性能不足时页面掉帧，<strong>导致卡顿</strong>。</li><li>发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li></ul><p>解决方法：实现异步可中断的更新</p><h2 id="老的-react-架构-react-15" tabindex="-1">老的 React 架构（React 15） <a class="header-anchor" href="#老的-react-架构-react-15" aria-label="Permalink to &quot;老的 React 架构（React 15）&quot;">​</a></h2><p>React15 架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件（Diff 算法）</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>Diff 算法将上一次更新的组件和本次更新的组件做对比，被判定为需要更新的组件，会被交给渲染器进行渲染，不同的渲染器会将不同的组件渲染到不同的宿主环境的视图中</p><h3 id="reconcile-协调器" tabindex="-1">Reconcile 协调器 <a class="header-anchor" href="#reconcile-协调器" aria-label="Permalink to &quot;Reconcile 协调器&quot;">​</a></h3><p><strong>在 React 15 中采用的是 stack reconciler 解决方案</strong></p><p>可以通过 <code>this.setState</code> 等 API 来触发更新，每次 <code>update</code> 时，协调器就会开始它的工作</p><ul><li>首先会开始 <code>render</code> 阶段的执行，<strong>将 JSX 转化成 Fiber Virtual DOM</strong></li><li>接着会前后两次的 Virtual DOM 进行对比，也就是 <strong>Diff 算法</strong>的工作，会对变更的节点打上对应的操作类型 effectTag</li><li>在 <code>commit</code> 阶段，会找到本次更新中变化的 Virtual DOM 节点</li><li>通知 <code>Renderer</code> 渲染器<strong>更新对应的视图</strong></li></ul><h3 id="renderer-渲染器" tabindex="-1">Renderer 渲染器 <a class="header-anchor" href="#renderer-渲染器" aria-label="Permalink to &quot;Renderer 渲染器&quot;">​</a></h3><p>React 最初只是服务于 DOM，但是这之后被改编成也能同时<strong>支持原生平台的 React Native</strong>。因此，在 React 内部机制中引入了“渲染器”这个概念。</p><p><strong>渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。</strong></p><ul><li><strong>React DOM Renderer</strong>： 将 React 组件渲染成 DOM。它实现了全局 ReactDOMAPI，这在npm上作为 react-dom 包。这也可以作为单独浏览器版本使用，称为 react-dom.js，导出一个 ReactDOM 的全局对象.</li><li><strong>React Native Renderer</strong>： 将 React 组件渲染为 Native 视图。此渲染器在 React Native 内部使用。</li><li><strong>React Test Renderer</strong>： 将 React 组件渲染为 JSON 树。这用于 Jest 的快照测试特性。在 npm 上作为 react-test-renderer 包发布。 另外一个官方支持的渲染器的是 react-art。它曾经是一个独立的 GitHub 仓库，但是现在我们将此加入了主源代码树。</li><li><a href="https://www.npmjs.com/package/react-art" target="_blank" rel="noreferrer">ReactArt Renderer</a> ：渲染到 Canvas, SVG 或 VML (IE8)</li></ul><p>在每次更新发生时，<strong>Renderer</strong> 接到 <strong>Reconciler</strong> 通知，将变化的组件渲染在当前宿主环境。</p><h2 id="react15-架构的缺点" tabindex="-1">React15 架构的缺点 <a class="header-anchor" href="#react15-架构的缺点" aria-label="Permalink to &quot;React15 架构的缺点&quot;">​</a></h2><p>在 <code>Reconciler</code> 阶段， 会递归的更新子组件，调用 <code>mount Component</code> 或 <code>update Component</code> 来实现，这也成为了它致命的缺点，<strong>一旦更新无法中断</strong></p><h3 id="递归更新的缺点" tabindex="-1">递归更新的缺点 <a class="header-anchor" href="#递归更新的缺点" aria-label="Permalink to &quot;递归更新的缺点&quot;">​</a></h3><p>当组件的层级很深时，无法在一帧内完成更新，又没有办法中断本次更新，用户交互就会变得卡顿</p><p>在 React 15 架构中，采用同步更新的方式，<code>Reconciler</code> 和 <code>Renderer</code> 是交替工作的，只有当前一个 DOM 完成了 <code>renderer</code> 才会<strong>进入下一个</strong> DOM 的 <code>Reconciler</code></p><p>在用户看来所有的 DOM 是同时更新的。</p><p>在前面说到，React 为了践行快速响应的理念，需要实现异步可中断的更新，那么基于 React 15 的架构能够实现吗？</p><p><strong>我们来演示一下在 React 15 架构下，如果触发更新的中断会发生什么？</strong></p><p>在下面的列子中，左边是更新前的页面，当我们点击时，会触发左侧数字 <code>count + 1</code>。正常情况，我们应当看到页面为 <code>2 3 4</code>。</p><p>当 2 更新为 3 后，我们中断了更新，由于 React 15 采用的是递归的更新，在上一个 DOM 完成更新之后才会开始下一个 DOM 的更新，因此就会看到右侧的页面，也就是 <code>2 3 3</code>，用户却<strong>看不到期望的值</strong>，也因此有了 React 16 的 Fiber 架构</p><p><img src="'+t+`" alt="image.png" data-fancybox="gallery"></p><h2 id="新的-react-架构" tabindex="-1">新的 React 架构 <a class="header-anchor" href="#新的-react-架构" aria-label="Permalink to &quot;新的 React 架构&quot;">​</a></h2><p>在 React 16 版本中进行了一次大的重构，React 16 架构<strong>解决了 React 15 不能支撑异步更新的问题</strong> React16 架构可以分为三层：</p><ul><li>Scheduler（调度器）—— <strong>调度任务的优先级</strong>，高优任务优先进入<strong>Reconciler</strong></li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><p>可以看到，相较于 React15，React16 中新增了 <strong>Scheduler</strong>(调度器)模块</p><p>在新的架构中，更新首先会被调度器处理，在调度器中会调度这些更新的优先级，更高优的更新会首先进入协调器，在本次更新的 <code>Reconcile</code> 中正在执行 Diff 算法时，<strong>如果此时产生了更高优先级的更新，本次正在协调的更新会被中断，由于 <code>Scheduler</code> 和 <code>Reconcile</code> 都是在视图中完成的操作，因此即使更新中断，用户也不会看到更新不完整的视图</strong>。当某次更新完成了 <code>Reconcile</code> 中的工作时，协调器会通知渲染器，本次更新有哪些组件需要执行对应的视图操作（CRUD），当渲染器完成了它的工作，调度器又会开始新一轮的调度</p><h3 id="scheduler-调度器" tabindex="-1">Scheduler 调度器 <a class="header-anchor" href="#scheduler-调度器" aria-label="Permalink to &quot;Scheduler 调度器&quot;">​</a></h3><p><strong>我们知道如果我们的应用占用较长的 js 执行时间，比如超过了设备一帧的时间，那么设备的绘制就会出现卡顿的现象。</strong></p><p>Scheduler 主要的功能是<strong>时间切片和调度优先级</strong>，react 在对比差异的时候会占用一定的 js 执行时间，Scheduler 内部借助 <code>MessageChannel</code> 实现了在浏览器绘制之前指定一个时间片，如果 react 在指定时间内没对比完，Scheduler 就会强制交出执行权给浏览器</p><p>在 Scheduler 的实现核心是，判断浏览器是否有剩余时间作为任务中断的标准，在部分浏览器中以及实现了这个 API，<code>requestIdle Callback</code>，但是 React 并没有直接使用这个 API ，<strong>而是自行实现了一个功能更加完备的 requestIdleCallback 的 polyfill，也就是 Scheduler。</strong></p><h3 id="reconcile-协调器-1" tabindex="-1">Reconcile 协调器 <a class="header-anchor" href="#reconcile-协调器-1" aria-label="Permalink to &quot;Reconcile 协调器&quot;">​</a></h3><p>在 React 15 的 <code>reconcile</code> 协调器中，会通过递归的方式来处理虚拟 DOM ，这样导致 <code>Reconcile</code> 过程无法被中断</p><p>React 16 推行 <code>Fiber reconciler</code> 的主要目标是：</p><ul><li>能够把可中断的任务切片处理。</li><li>能够调整优先级，重置并复用任务。</li><li>能够在父元素与子元素之间交错处理，以支持 React 中的布局。</li><li>能够在 <code>render()</code> 中返回多个元素。</li><li>更好地支持错误边界。</li></ul><p>在 React 16 中将更新工作从递归变成了可以中断的循环过程，每次循环都会调用 shouldYield 判断当前是否有剩余时间</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoopConcurrent</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 判断是否中断</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><strong>那么 React 16 是如何解决更新中断时 DOM 渲染不完全的问题呢？</strong></p><p>在 React 16 中，Reconciler 与 Renderer <strong>不再是交替工作</strong>。当 Scheduler 调度器将任务交给 Reconciler 后，Reconciler <strong>会为变化的 DOM 打上标记 effectTag</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Placement </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*             */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000010</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Update </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> PlacementAndUpdate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*    */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000110</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Deletion </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*              */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000001000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>只有再所有组件都完成了 <code>Reconciler</code> 的工作，才会统一交给 <code>Renderer</code> 渲染器进行更新渲染</p><h3 id="renderer-渲染器-1" tabindex="-1">Renderer 渲染器 <a class="header-anchor" href="#renderer-渲染器-1" aria-label="Permalink to &quot;Renderer 渲染器&quot;">​</a></h3><p>Renderer 会根据 Reconciler 中为虚拟 DOM 打的 tag，在 commit 阶段<strong>同步执行</strong>对应的 DOM 操作</p><p>同样也有多种不同的渲染器，和 React 15 中保持一致</p><p>以上就是 React 的设计理念以及新老架构的演变</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://react.iamkasong.com/preparation/oldConstructure.html#react15%E6%9E%B6%E6%9E%84" target="_blank" rel="noreferrer">React 技术揭秘</a> -- React 15 架构</li></ul>`,56),c=[r];function p(i,d,D,y,h,g){return s(),a("div",null,c)}const F=e(l,[["render",p]]);export{u as __pageData,F as default};
