import{_ as e,c as o,o as c,V as t}from"./chunks/framework.3d11d069.js";const _=JSON.parse('{"title":"Q & A","description":"","frontmatter":{},"headers":[],"relativePath":"pages/react/hard/commit/qa.md","filePath":"pages/react/hard/commit/qa.md","lastUpdated":1691331669000}'),a={name:"pages/react/hard/commit/qa.md"},d=t('<h1 id="q-a" tabindex="-1">Q &amp; A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q &amp; A&quot;">​</a></h1><h2 id="q-useeffect-的销毁函数是什么时候执行" tabindex="-1">Q: useEffect 的销毁函数是什么时候执行？ <a class="header-anchor" href="#q-useeffect-的销毁函数是什么时候执行" aria-label="Permalink to &quot;Q: useEffect 的销毁函数是什么时候执行？&quot;">​</a></h2><p>A:</p><p><code>useEffect</code> 的销毁函数是在 <code>commit</code> 阶段的 <code>layout</code> 阶段渲染视图完成之后执行的，<code>useEffect</code> 会在 <code>beforemutation</code> 阶段以一个 <code>normal</code> 的优先级被 <code>schedule</code> 调度。 在视图渲染后就会处理这个 <code>effect</code>，会先执行 <code>destroy</code> 再执行 <code>create</code> 。 相比之下，<code>uselayouteffect</code> 会在 <code>mutation</code> 阶段执行 <code>destroy</code> ,<code>layout</code> 阶段执行 <code>create</code></p><h2 id="q-ref-的更新究竟是-mutation-阶段还是-layout-阶段执行的" tabindex="-1">Q: ref 的更新究竟是 mutation 阶段还是 layout 阶段执行的？ <a class="header-anchor" href="#q-ref-的更新究竟是-mutation-阶段还是-layout-阶段执行的" aria-label="Permalink to &quot;Q: ref 的更新究竟是 mutation 阶段还是 layout 阶段执行的？&quot;">​</a></h2><p>准确来说应该是在 <code>mutation</code> 阶段会解除 <code>ref</code> 的引用，在 <code>layout</code> 阶段重新绑定。这里涉及到两个方法，一个是 <code>commitDetachRef</code> 还有一个就是 <code>commitAttachRef</code>，在 <code>mutation</code> 阶段会先用前面的方法接触 <code>ref</code> 的引用，在 <code>DOM</code> 更新完成后，在 <code>layout</code> 阶段会再调用 <code>commitAttachRef</code> 去绑定新的 <code>ref</code></p>',6),r=[d];function s(i,f,m,n,u,l){return c(),o("div",null,r)}const p=e(a,[["render",s]]);export{_ as __pageData,p as default};
