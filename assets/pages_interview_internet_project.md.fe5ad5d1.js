import{_ as e,c as t,o as a,V as r}from"./chunks/framework.3d11d069.js";const u=JSON.parse('{"title":"项目问题","description":"","frontmatter":{},"headers":[],"relativePath":"pages/interview/internet/project.md","filePath":"pages/interview/internet/project.md","lastUpdated":1691330563000}'),o={name:"pages/interview/internet/project.md"},s=r('<h1 id="项目问题" tabindex="-1">项目问题 <a class="header-anchor" href="#项目问题" aria-label="Permalink to &quot;项目问题&quot;">​</a></h1><h3 id="封装请求函数都做了什么工作" tabindex="-1">封装请求函数都做了什么工作 <a class="header-anchor" href="#封装请求函数都做了什么工作" aria-label="Permalink to &quot;封装请求函数都做了什么工作&quot;">​</a></h3><p>主要是利用做请求拦截和响应拦截，先从请求说起，处理默认的 URL、请求头内容，requestId、token 做登录验证等，以及 axios 的超时时间等参数。在响应部分会对错误码进行判断，对一些特定的错误码进行提示，比如鉴权失败等，在这里统一做处理，避免每次请求都做处理，同时对错误信息返回格式进行统一。通过 new Error 返回。同时我们还可以在这里做请求数据 mock。</p><p>通过请求拦截和响应拦截封装出统一的请求方法 implSever，然后我们可以再做进一步封装，比如对不同服务进行区分，在同一个命名空间内进行调用，通过 bind 以及柯里化的思想，先传入请求 url、mock 信息等，在调用时直接传入参数即可。</p><p>这里还可以通过 protobuf 等库对后端协议进行转化，自动生成 .d.ts 文件以及 .ts 的 implSever 文件，自动按照服务进行划分。</p><h3 id="d-ts-文件的作用是什么-它是如何工作的" tabindex="-1">.d.ts 文件的作用是什么，它是如何工作的？ <a class="header-anchor" href="#d-ts-文件的作用是什么-它是如何工作的" aria-label="Permalink to &quot;.d.ts 文件的作用是什么，它是如何工作的？&quot;">​</a></h3><p>Typescript 会自动检查项目中的所有 .d.ts 文件来做类型检查</p>',7),i=[s];function n(c,d,p,_,l,h){return a(),t("div",null,i)}const f=e(o,[["render",n]]);export{u as __pageData,f as default};
