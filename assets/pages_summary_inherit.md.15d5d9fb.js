import{_ as s,c as a,o as n,U as l}from"./chunks/framework.4d5e0f31.js";const C=JSON.parse('{"title":"JS 继承的7种方法，你学会了吗？","description":"💌 前言 在上一篇文章中我们讲解了原型链的机制以及原型相关的一些属性，而与原型链息息相关的就是继承了，为什么这么说呢？","frontmatter":{"title":"JS 继承的7种方法，你学会了吗？","date":"2021-08-17T21:05:50.000Z","id":1635645890,"photos":"https://ljcimg.oss-cn-beijing.aliyuncs.com/img/7%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.png","tags":["继承","JavaScript"],"categories":["前端总结"],"keywords":"继承,JavaScript7种继承方式,小丞同学","description":"💌 前言 在上一篇文章中我们讲解了原型链的机制以及原型相关的一些属性，而与原型链息息相关的就是继承了，为什么这么说呢？"},"headers":[],"relativePath":"pages/summary/inherit.md","lastUpdated":1682694591000}'),o={name:"pages/summary/inherit.md"},p=l(`<blockquote><p>📢 大家好，我是小丞同学，本文主要写 JavaScript 中的 7 种继承方式，深入理解每种方式所存在的问题同时新的方式是如何解决问题的</p><p>📢 非常感谢你的阅读，不对的地方欢迎指正 🙏</p><p>📢 <div color="#e84393">愿你生活明朗，万物可爱</div></p></blockquote><h2 id="💌-前言" tabindex="-1">💌 前言 <a class="header-anchor" href="#💌-前言" aria-label="Permalink to &quot;💌 前言&quot;">​</a></h2><p>在上一篇文章中我们讲解了原型链的机制以及原型相关的一些属性，而与原型链息息相关的就是继承了，为什么这么说呢？</p><p>在《JavaScript 高级程序设计》上，有这么一句话</p><p>“实现继承是 <code>ECMAScript</code> 唯一支持的继承方式，且这主要通过<strong>原型链</strong>来实现。”</p><p>可想而知，原型链在继承中起着至关重要的主要</p><p>在全文开始之前，不妨先来看看本文纲要</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210816230355022.png" alt="image-20210816230355022" data-fancybox="gallery"></p><h2 id="💟息息相关的-6-种继承方式" tabindex="-1">💟息息相关的 6 种继承方式 <a class="header-anchor" href="#💟息息相关的-6-种继承方式" aria-label="Permalink to &quot;💟息息相关的 6 种继承方式&quot;">​</a></h2><p>在 ES6 到来之前，基于 ES5 实现的继承，在每一代中都优化了上一代带来的问题，这也是 JavaScript 语言中值得我们学习的一点，遇到问题，解决问题，不断优化，接下来我们来看看它们是如何一步步实现的</p><h3 id="🍏-一、原型链继承" tabindex="-1">🍏 一、原型链继承 <a class="header-anchor" href="#🍏-一、原型链继承" aria-label="Permalink to &quot;🍏 一、原型链继承&quot;">​</a></h3><h4 id="_1-基本思想" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><blockquote><p>原型链继承的基本思想是通过<strong>原型</strong>来继承多个引用类型的属性和方法</p></blockquote><p>实现的<strong>基本思路</strong>是利用构造函数实例化对象，通过 <code>new</code> 关键字，将<strong>构造函数的实例对象</strong>作为子类函数的原型对象</p><h4 id="_2-实现方法" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 定义父类函数</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 定义父类属性</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">father</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 给父类的原型添加方法</span></span>
<span class="line"><span style="color:#FFCB6B;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">say</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">我是爸爸</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建子类函数</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 实现继承</span></span>
<span class="line"><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 打印参考</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype) </span><span style="color:#676E95;font-style:italic;">// Father {name: &quot;father&quot;}</span></span>
<span class="line"></span></code></pre></div><p>我们来解释一下上面的代码，首先定义了一个父函数和子函数，添加了一些属性和方法</p><p>而实现继承的关键在于 <code>Son.prototype = new Father()</code> 。那它怎么理解呢</p><p>首先我们需要了解一下 <code>new</code> 操作符的执行过程</p><ol><li>创建一个空对象</li><li>继承函数原型，将这个新对象的 <code>__proto__</code> 属性赋值为构造函数的原型对象</li><li>构造函数内部的 <code>this</code> 指向新对象</li><li>执行函数体</li><li>返回这个新对象</li></ol><p>明白了 <code>new</code> 的过程后，我们可以知道当我们在 <code>new Father()</code> 操作时，这一步将 <code>Father</code> 构造函数的原型对象打包给了 <code>Father</code> 的实例对象，也就是 <code>father.__proto__ = Father.prototype </code>，换到这里也就是 <code>Son.prototype.__proto__ = Father.prototype</code>，这样一来也就是<strong>将父类的实例对象作为了子类的原型</strong>，这也一来就在子类与父类实现了连接</p><p>关键性代码：<code>son.prototype = new Father()</code></p><h4 id="_3-存在的问题" tabindex="-1">3. 存在的问题 <a class="header-anchor" href="#_3-存在的问题" aria-label="Permalink to &quot;3. 存在的问题&quot;">​</a></h4><p>通过上面的分析，整体上感觉不出什么问题，但是我们来看一下这个例子</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// 定义父类属性为引用数据类型</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>我们将上面的代码中 <code>a</code> 的值改成引用数据类型，我们知道对于引用数据类型只会保存对它的引用，也就是内存地址。</p><p>我们先创建两个继承这个父类的子类 <code>son1 ，son2</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div><p>接着我们想向 <code>son1</code> 中的 <code>a</code> 数组添加一个值 5 ，我们会这么操作</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">son1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>不用多想<code>son1</code>肯定成功添加了，但是我们再打印一下此时的<code>son2</code>，我们会发现它的 <code>a</code> 数组也被改变了</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817083710044.png" alt="image-20210817083710044" data-fancybox="gallery"></p><p>而这就是原型链继承方式带来的引用数据类型被子类共享的问题</p><h4 id="_4-优点与不足" tabindex="-1">4. 优点与不足 <a class="header-anchor" href="#_4-优点与不足" aria-label="Permalink to &quot;4. 优点与不足&quot;">​</a></h4><h5 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>父类的方法可以复用</li><li>操作简单</li></ul><h5 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h5><ul><li>对于引用数据类型数据会被子类共享，也就是改一个其他都会改</li><li>创建子类实例时，无法向父类构造函数传参，不够灵活。</li></ul><h3 id="🍉-二、盗用构造函数继承" tabindex="-1">🍉 二、盗用构造函数继承 <a class="header-anchor" href="#🍉-二、盗用构造函数继承" aria-label="Permalink to &quot;🍉 二、盗用构造函数继承&quot;">​</a></h3><p>为了解决原型链继承方式带来的引用值无法共享的问题，从而兴起了一种“盗用构造函数继承”的方式</p><h4 id="_1-基本思想-1" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想-1" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><p>为了想要实现<strong>引用值共享</strong>的问题，我们就不能给子类直接使用原型对象上的引用值。</p><p>因此，可以在子类构造函数中调用父类构造函数。</p><p>我们从一段简易的代码入手</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如果我们将子类的代码改写成这样，会发生什么呢？</p><p>当我们通过 <code>Son</code> 构造函数实例化实例对象时，每个实例对象中变量 <code>a</code> 都是独立的，属于自身的，当我们修改一个时，不会影响另一个的值</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817092755942.png" alt="image-20210817092755942" data-fancybox="gallery"></p><p>这也就是盗用构造函数继承的原理</p><h4 id="_2-实现方法-1" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法-1" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">son1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(son1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> son2)</span></span>
<span class="line"></span></code></pre></div><p>我们可以看到，在上面的实现方式中，并没有直接采用 <code>this.a...</code> 而是采用了 <code>Father.call(this)</code></p><p>如果直接采用 <code>this.a</code> 的话，这还叫做继承吗？是吧</p><p>那么采用 <code>Father.call(this)</code> 又是什么道理呢？</p><p>我们原先直接将 <code>this.a</code> 直接的写在了子类函数里面，这和直接在子类中调用 <code>Father</code> 方法是类似的，唯一的差别就是 <code>this</code> 指向问题</p><p>如果直接的在子类中调用 <code>Father()</code> ，那么它的 <code>this</code> 将指向 <code>window</code> ，这样就无法将数据绑定到实例身上，因此我们需要改变 <code>this</code> 的指向，指向当前的子类构造函数</p><p>这样一来就能将数据绑定到了每个实例对象身上</p><p>同时由于我们的关键语句采用的是 <code>call</code>，因此我们可以给父类构造函数传递参数，实现传递参数</p><h4 id="_3-存在的问题-1" tabindex="-1">3. 存在的问题 <a class="header-anchor" href="#_3-存在的问题-1" aria-label="Permalink to &quot;3. 存在的问题&quot;">​</a></h4><p>从上面的实现代码中，相信大家都能看出来，我有意的忽略了原型的操作，没有在父类构造函数的原型上添加方法，而这个就是这种方法存在的问题</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">say</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">111</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817095321861.png" alt="image-20210817095321861" data-fancybox="gallery"></p><p>无法在子类上找到 <code>say</code> 方法</p><h4 id="_4-优点与不足-1" tabindex="-1">4. 优点与不足 <a class="header-anchor" href="#_4-优点与不足-1" aria-label="Permalink to &quot;4. 优点与不足&quot;">​</a></h4><h5 id="优点-1" tabindex="-1">优点： <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>解决了无法共享引用值的问题</li><li>能够传递参数</li></ul><h5 id="缺点-1" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点：&quot;">​</a></h5><ul><li>只能继承父类的实例属性和方法，不能继承父类的<strong>原型</strong>属性和方法</li><li>父类方法无法复用。每次实例化子类，都要执行父类函数。重新声明父类所定义的方法，无法复用。</li></ul><h3 id="🍊-三、组合继承" tabindex="-1">🍊 三、组合继承 <a class="header-anchor" href="#🍊-三、组合继承" aria-label="Permalink to &quot;🍊 三、组合继承&quot;">​</a></h3><p>在前面两种方法中，都存在着一定的缺陷，所以很少会将它们单独使用。为此一种新的继承方式就诞生了：组合继承（伪经典继承），组合继承结合了原型链与盗用构造函数继承的方式，将两者的优点结合在一起。</p><h4 id="_1-基本思想-2" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想-2" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><p>通过原型链继承方式继承父类原型上的属性和方法，再使用盗用构造函数的方式继承实例上的属性</p><p>这样，实现了把方法定义在原型上以实现复用，又保证了让每个实例都有自己的属性</p><h4 id="_2-实现方法-2" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法-2" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><p>将两种方法和并在一起</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">say</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">111</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div><p>其实只是在盗用构造函数的基础上添加了原型链继承的关键性代码</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div><p>在上面的代码中，通过盗用构造函数的方法继承了父类实例上的属性 <code>a</code> ，通过原型链的方式，继承了父类的原型对象</p><p>关于具体过程也只是两个的结合，可以翻翻前面的解释</p><h4 id="_3-存在的问题-2" tabindex="-1">3. 存在的问题 <a class="header-anchor" href="#_3-存在的问题-2" aria-label="Permalink to &quot;3. 存在的问题&quot;">​</a></h4><p>首先我们来打印一下 <code>son1和son2</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817114337643.png" alt="image-20210817114337643" data-fancybox="gallery"></p><p>输出了这样的结果，我们发现在它的原型对象上也有一个属性 <code>a</code> ，但是这个似乎是初始值，我们来想一想这是为什么？</p><p>我们将 <code>Father</code> 的实例绑定在了 <code>Son</code> 的原型上，但是我们又通过盗用构造函数的方法</p><p>将 <code>Father</code> 自身的属性手动添加到了 <code>Son</code> 的身上，因此在 <code>Son</code> 实例化出来的对象上，会有一个 <code>a</code> 属性，原型上也会有一个 <code>a</code> 属性</p><p>那这样会造成什么问题呢？</p><p>回答这个问题之前，我们先来数数调用了几次 <code>Father</code> 构造函数，</p><ol><li>在 <code>new</code> 的时候</li><li>在 <code>call</code> 的时候</li></ol><p>因此一方面会有一定的性能问题，还有一方面就是会出现 2 个属性</p><h4 id="_4-优点和不足" tabindex="-1">4. 优点和不足 <a class="header-anchor" href="#_4-优点和不足" aria-label="Permalink to &quot;4. 优点和不足&quot;">​</a></h4><h5 id="优点-2" tabindex="-1">优点： <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>解决原型链继承中属性被共享的问题</li><li>解决借用构造函数解决不能继承父类原型对象的问题</li></ul><h5 id="缺点-2" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点：&quot;">​</a></h5><ul><li>调用了两次的父类函数，有性能问题</li><li>由于两次调用，会造成实例和原型上有相同的属性或方法</li></ul><h3 id="🍋-四、原型式继承" tabindex="-1">🍋 四、原型式继承 <a class="header-anchor" href="#🍋-四、原型式继承" aria-label="Permalink to &quot;🍋 四、原型式继承&quot;">​</a></h3><p>我似乎找不到这种继承方式的存在意义，不知道它解决了组合模式的什么问题？</p><h4 id="_1-基本思想-3" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想-3" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><p>原型式继承实现的思路是：直接将对象赋值给构造函数的原型</p><h4 id="_2-实现方法-3" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法-3" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">object</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#89DDFF;">(){};</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 将对象赋值给构造函数的原型</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">F</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 返回 new 期间创建的新对象</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这个 <code>object</code> 函数会创建一个临时构造函数，将传入的对象赋值给构造函数的原型，然后返回这个临时构造函数的实例</p><p>那我们怎么用呢</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> student </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> another </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">object</span><span style="color:#A6ACCD;">(student)</span></span>
<span class="line"></span></code></pre></div><p>我们需要先准备好一个父类对象，也就是要被继承的对象，然后作为参数传入<code>object</code>函数，返回的对象就是一个以这个父类对象为原型对象的对象</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817124252511.png" alt="image-20210817124252511" data-fancybox="gallery"></p><h4 id="_3-存在的问题-3" tabindex="-1">3. 存在的问题 <a class="header-anchor" href="#_3-存在的问题-3" aria-label="Permalink to &quot;3. 存在的问题&quot;">​</a></h4><p>其实它存在的问题和原型链继承的问题相同，属性和方法被共享</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> student </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ljc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> one </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">object</span><span style="color:#A6ACCD;">(student)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> two </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">object</span><span style="color:#A6ACCD;">(student)</span></span>
<span class="line"><span style="color:#A6ACCD;">one</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">aaa</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">two</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bbb</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>我们分别给<code>one,two</code>对象中的<code>name</code>数组添加属性，再来打印一下<code>one.name</code></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817125947227.png" alt="image-20210817125947227" data-fancybox="gallery"></p><p>这样又造成了被共享的问题</p><h4 id="_4-优点和不足-1" tabindex="-1">4. 优点和不足 <a class="header-anchor" href="#_4-优点和不足-1" aria-label="Permalink to &quot;4. 优点和不足&quot;">​</a></h4><h5 id="优点-3" tabindex="-1">优点： <a class="header-anchor" href="#优点-3" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>兼容性好，简单</li><li>不需要单独创建构造函数</li></ul><h5 id="缺点-3" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点：&quot;">​</a></h5><ul><li>多个实例共享被继承的属性，存在被篡改的情况</li><li>不能传递参数</li></ul><blockquote><p><code>ES5</code> 中增加的 <code>Object.create()</code> 的方法，能够代替上面的 <code>object</code> 方法。也为原型式继承提供了规范</p></blockquote><h3 id="🍌-五、寄生式继承" tabindex="-1">🍌 五、寄生式继承 <a class="header-anchor" href="#🍌-五、寄生式继承" aria-label="Permalink to &quot;🍌 五、寄生式继承&quot;">​</a></h3><h4 id="_1-基本思想-4" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想-4" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><p>创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后返回对象。</p><p>也就是在原型式继承的基础上进行<strong>增强对象</strong>。</p><h4 id="_2-实现方法-4" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法-4" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createAnother</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">original</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">clone</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">object</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">original</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 继承一个对象 返回新函数</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">clone</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayHi</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hi</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">clone</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 返回这个对象</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>在这段代码中，似乎只是在原有对象的基础上，给对象添加了一个方法，并封装成了一个函数，供我们直接使用</p><h4 id="_3-优点和不足" tabindex="-1">3. 优点和不足 <a class="header-anchor" href="#_3-优点和不足" aria-label="Permalink to &quot;3. 优点和不足&quot;">​</a></h4><h5 id="优点-4" tabindex="-1">优点： <a class="header-anchor" href="#优点-4" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li>只需要关注对象本身，不在乎类型和构造函数的场景</li></ul><h5 id="缺点-4" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-4" aria-label="Permalink to &quot;缺点：&quot;">​</a></h5><ul><li>函数难以重用</li><li>多个实例共享被继承的属性，存在被篡改的情况</li><li>无法传递参数</li></ul><h3 id="🍑-六、寄生式组合继承" tabindex="-1">🍑 六、寄生式组合继承 <a class="header-anchor" href="#🍑-六、寄生式组合继承" aria-label="Permalink to &quot;🍑 六、寄生式组合继承&quot;">​</a></h3><p>组合继承仍然着效率的问题，最主要的问题是，父类构造函数始终会被调用 2 次</p><h4 id="_1-基本思想-5" tabindex="-1">1. 基本思想 <a class="header-anchor" href="#_1-基本思想-5" aria-label="Permalink to &quot;1. 基本思想&quot;">​</a></h4><p>结合组合继承和寄生式继承结合来实现减少对父类的调用次数，从而达到目的</p><h4 id="_2-实现方法-5" tabindex="-1">2. 实现方法 <a class="header-anchor" href="#_2-实现方法-5" aria-label="Permalink to &quot;2. 实现方法&quot;">​</a></h4><p>在组合继承的方法中我们 <code>call</code> 了一次，又 <code>new</code> 了一次，导致调用了2次父类，而在寄生式继承中，我们可以调用 API 来实现继承父类的原型</p><p>我们将两者结合在一起</p><p>不再采用 <code>new</code> 关键字来给改变原型</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Father</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">say</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">111</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(Father)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> son2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Son</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div><p>采用 <code>Object.create</code> 来重写子类的原型，这样就减少了对父类的调用</p><p>这时我们在控制台打印 <code>son1</code> 会发现问题解决了</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817174003097.png" alt="image-20210817174003097" data-fancybox="gallery"></p><h4 id="_3-存在的问题-4" tabindex="-1">3. 存在的问题 <a class="header-anchor" href="#_3-存在的问题-4" aria-label="Permalink to &quot;3. 存在的问题&quot;">​</a></h4><p>在这种方法中，同样存在着一些问题，当我们的子类原型上有方法时</p><p>会因为原型被重写而丢失了这些方法</p><p>我们在代码最上方添加上一个 <code>sayHi</code> 方法</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Son</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayHi</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hi</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817174246873.png" alt="image-20210817174246873" data-fancybox="gallery"></p><p>要想解决这个问题，其实可以在<strong>原型被重写之后</strong>再添加子类原型的方法</p><h4 id="_4-优点和不足-2" tabindex="-1">4. 优点和不足 <a class="header-anchor" href="#_4-优点和不足-2" aria-label="Permalink to &quot;4. 优点和不足&quot;">​</a></h4><h5 id="优点-5" tabindex="-1">优点： <a class="header-anchor" href="#优点-5" aria-label="Permalink to &quot;优点：&quot;">​</a></h5><ul><li><p>基本上是最佳的继承方案了，当然还有圣杯继承</p></li><li><p>只调用了父类构造函数一次，节约了性能。</p></li><li><p>避免生成了不必要的属性</p></li></ul><h5 id="缺点-5" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-5" aria-label="Permalink to &quot;缺点：&quot;">​</a></h5><ul><li>子类原型被重写</li></ul><blockquote><p>以上就是介绍的ES5中的6种继承方式</p></blockquote><h2 id="es6-中的继承🎭" tabindex="-1">ES6 中的继承🎭 <a class="header-anchor" href="#es6-中的继承🎭" aria-label="Permalink to &quot;ES6 中的继承🎭&quot;">​</a></h2><p>由于 ES6 之前的继承过于复杂，代码太多，再 ES6 中引入了一种新的继承方式 <code>extends</code> 继承</p><p>采用 <code>extends</code> 关键字来实现继承</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Father</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Son</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Father</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这样就实现了子类继承父类，这里的关键是需要在子类的 <code>constructor</code> 中添加一个 <code>super</code> 关键字</p><p><strong>需要注意的是</strong></p><p>子类中<code>constructor</code>方法中必须引用<code>super</code>方法，否则新建实例会报错，这是因为子类自己的 <code>this</code> 对象，必须<strong>先通过</strong>父类构造函数完成塑性，得到父类的属性和方法</p><p>然后再加上子类自己的属性和方法</p><p>如果没有 <code>super</code> 方法，子类就没有 <code>this</code> 对象，就会报错</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210817194042644.png" alt="image-20210817194042644" data-fancybox="gallery"></p><p>关于 class 的东西还有很多，这里就不多说了</p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><p>《JavaScript 高级程序设计》</p><p><a href="https://juejin.cn/post/6844903696111763470#heading-7" target="_blank" rel="noreferrer">《JavaScript常见八种继承方案》</a></p><hr><p>以上就是关于 JS 实现继承的 7 种方法了，当然还会有一些其他的继承方法，圣杯模式继承，拷贝继承等等一大堆就不多说了</p><blockquote><p>以上就是本文的全部内容了，希望你能喜欢💛，有什么问题可以评论区留言噢~</p></blockquote>`,172),e=[p];function t(c,r,y,F,i,D){return n(),a("div",null,e)}const d=s(o,[["render",t]]);export{C as __pageData,d as default};
