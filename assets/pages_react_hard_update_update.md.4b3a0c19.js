import{_ as e,c as o,o as d,V as a}from"./chunks/framework.3d11d069.js";const t="/assets/1.103fe364.png",r="/assets/2.cad6657e.png",m=JSON.parse('{"title":"状态更新流程概览","description":"","frontmatter":{},"headers":[],"relativePath":"pages/react/hard/update/update.md","filePath":"pages/react/hard/update/update.md","lastUpdated":1690954695000}'),c={name:"pages/react/hard/update/update.md"},i=a('<h1 id="状态更新流程概览" tabindex="-1">状态更新流程概览 <a class="header-anchor" href="#状态更新流程概览" aria-label="Permalink to &quot;状态更新流程概览&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>前面我们讲了 <code>render</code> 阶段和 <code>commit</code> 阶段的工作，讲了 <code>render</code> 阶段中 Diff 算法的实现，现在我们已经对整体的流程有了一定的认识</p><ul><li>在 <code>render</code> 阶段的 <code>beginWork</code> 阶段会创建子 <code>Fiber</code> 节点，通过 Diff 算法，打上相应的 <code>effectTag</code></li><li>在 <code>render</code> 阶段的 <code>completeWork</code> 阶段会根据 <code>Fiber</code> 节点生成对应的 <code>DOM</code> 节点，并连接子节点</li><li>在 <code>commit</code> 阶段会对所有的 <code>effectTag</code> 执行相应的 DOM 操作，更新视图</li></ul><p>在这些流程之前还有着，从<strong>触发状态更新到 <code>render</code> 阶段</strong>的过程，也就是我们本章需要学习的内容：<strong>状态更新</strong></p><p>首先我们先了解一下什么是<strong>最小更新单元</strong></p><h2 id="最小更新单元" tabindex="-1">最小更新单元 <a class="header-anchor" href="#最小更新单元" aria-label="Permalink to &quot;最小更新单元&quot;">​</a></h2><p>我们从实例来看，对于一个组件来说，如果想要触发更新，那么可以有以下这些情况</p><ul><li>组件本身的 <code>state</code> 发生改变</li><li>组件 <code>props</code> 的改变，也就是父组件状态导致子组件更新</li><li><code>context</code> 改变，该组件消费的 <code>context</code> 发生了更新</li></ul><p>但是归根结底，无论是哪种场景下触发的更新，最终的本质都是 <code>state</code> 的变化导致的<br> 对于 React 来说，能够触发 state 更新的基本都是<strong>在组件层面</strong>上，毕竟 Fiber 没有办法实现自我更新，只能依赖组件进行 <code>state</code> 更想你<br> 因此，我们可以认为 <strong>最小的更新单元是组件，更新源自于 state 的变化</strong></p><p><strong>那么如何触发更新呢？</strong></p><h2 id="触发更新" tabindex="-1">触发更新 <a class="header-anchor" href="#触发更新" aria-label="Permalink to &quot;触发更新&quot;">​</a></h2><p>竟然组件是最小的更新单元，那么我们可以知道，触发更新可以分为</p><ul><li>类组件的 <code>setState</code> 状态更新</li><li>函数组件的 <code>useState</code> 状态更新</li></ul><p><strong>那么，状态更新都会触发哪些流程呢？</strong></p><h2 id="创建-update-对象" tabindex="-1">创建 Update 对象 <a class="header-anchor" href="#创建-update-对象" aria-label="Permalink to &quot;创建 Update 对象&quot;">​</a></h2><p>首先，每次状态更新都会创建一个保存更新状态内容的对象，也就是 Update 对象，保存在 updateQueue 链表中，记录当前 Fiber 节点收集到的更新。在 <code>render</code> 阶段的 <code>beginWork</code> 中会根据 <code>Update</code> 对象来计算新的 <code>state</code><br><img src="'+t+'" alt="image.png" data-fancybox="gallery">)<br>这个 Update 会被保存在一个环状链表中，接下来会调用 <code>scheduleUpdateOnFiber</code> 方法，来调度这个 Update</p><h2 id="标记-rootfiber" tabindex="-1">标记 RootFiber <a class="header-anchor" href="#标记-rootfiber" aria-label="Permalink to &quot;标记 RootFiber&quot;">​</a></h2><p>我们知道 <code>render</code> 阶段是从 <code>rootFiber</code> 开始向下遍历，因此我们需要在 <code>render</code> 阶段开始之前，让 <code>rootFiber</code> 知道本次调度的相关信息。<br>因此我们需要从当前触发更新的节点对应的 Fiber <strong>一直遍历到应用的根节点 rootFiber</strong>，并通知沿途的 Fiber，你有子孙节点被更新了，打上<strong>本次触发更新的优先级标记</strong>，并返回 rootFiber<br>这一步叫做 <code>markUpdateLaneFromFiberToRoot</code></p><h2 id="调度更新" tabindex="-1">调度更新 <a class="header-anchor" href="#调度更新" aria-label="Permalink to &quot;调度更新&quot;">​</a></h2><p>经过了上面的处理，我们已经获取到了 <code>RootFiber</code>，并且在这个 Fiber 上同时标记了子树中的 Update<br>接下来，需要通知 Scheduler 调度器来根据更新的优先级，以及任务的类型，来发起异步或是同步的更新调度，这一步调用的是 <code>ensureRootIsScheduled</code> 方法</p><ul><li>对于 legacy 模式下，最后执行的是 <code>performSyncWorkOnRoot</code> 方法</li><li>对于 concurrent 模式，最后执行的是 <code>performConcurrentWorkOnRoot</code> 方法</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>当调度的回调函数被执行，会进入组件的 <code>render</code> 阶段</p><ul><li>在 <code>render</code> 阶段的 <code>reconcile</code> 也就是 diff 算法中，会根据 <code>Update</code> 对象，返回对应的 <code>state</code>，根据 <code>state</code> 判断本次是否需要更新视图，如果需要更新视图就会被标记为 <code>effectTag</code></li><li>在 <code>commit</code> 阶段，标记了 <code>effectTag</code> 的 <code>Fiber</code>，就会执行对应的视图更新</li></ul><p><img src="'+r+'" alt="image.png" data-fancybox="gallery"></p>',26),n=[i];function l(s,p,h,u,b,g){return d(),o("div",null,n)}const _=e(c,[["render",l]]);export{m as __pageData,_ as default};
