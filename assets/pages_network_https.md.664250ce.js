import{_ as a,c as t,o as l,V as i}from"./chunks/framework.3d11d069.js";const S=JSON.parse('{"title":"HTTPS 相关面试题","description":"","frontmatter":{},"headers":[],"relativePath":"pages/network/https.md","filePath":"pages/network/https.md","lastUpdated":1687532023000}'),e={name:"pages/network/https.md"},s=i('<h1 id="https-相关面试题" tabindex="-1">HTTPS 相关面试题 <a class="header-anchor" href="#https-相关面试题" aria-label="Permalink to &quot;HTTPS 相关面试题&quot;">​</a></h1><h2 id="https-了解吗" tabindex="-1">HTTPS 了解吗？ <a class="header-anchor" href="#https-了解吗" aria-label="Permalink to &quot;HTTPS 了解吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>HTTPS 是采用 TLS 加密的 HTTP 协议，可以说是 HTTP 的安全版本，通过 TLS 协议对数据传输进行加密，以确保安全性</p><p>主要有 3 个特点，数据加密、数据不可被篡改、身份可验证</p></div><h2 id="rsa-的握手过程" tabindex="-1">RSA 的握手过程？ <a class="header-anchor" href="#rsa-的握手过程" aria-label="Permalink to &quot;RSA 的握手过程？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>首先客户端发送一个 客户端随机数、TLS 版本号、加密套件给服务器</li><li>服务器确认 TLS 版本号，同时生成服务端随机数、需要的加密套件、CA 证书，发送给客户端</li><li>客户端收到后，会对证书进行验证，如果验证成功会用 CA 证书的公钥生成一个 pre-master ，发送给服务器，并将前面通信的内容生成摘要，用 pre-master 加密，发送给服务器以验证通信内容没有被篡改。之后改用密钥通信</li><li>此时客户端有客户端随机数、服务端随机数、pre-master，可以计算出会话密钥</li><li>服务端收到用公钥加密的 pre-master 会用私钥进行解密，得到 pre-master 的内容，用同样的方式生成会话密钥，之后改用密钥通信</li><li>之后就用这个对称密钥加密报文传输。</li></ol></div><h2 id="追问-证书是如何认证的" tabindex="-1">（追问）证书是如何认证的？ <a class="header-anchor" href="#追问-证书是如何认证的" aria-label="Permalink to &quot;（追问）证书是如何认证的？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>其实认证证书就是通过浏览器或操作系统中的 CA 公钥解密证书的数字签名，得到证书数据的 hash，然后对数字证书的数据部分用同样的 hash 算法，生成 hash，对比 hash，来验证是否被篡改。</p><p>证书是服务器向 CA 申请的，需要提供服务端的公钥等相关信息，CA 会对服务器真实性进行验证，会把公钥还有相关信息打包成一个证书，对这个证书进行 hash + CA 密钥加密得到数字签名。最后 CA 会给服务端颁发数字签名后的证书。</p></div><h2 id="追问-rsa-有什么缺陷吗" tabindex="-1">（追问）RSA 有什么缺陷吗？ <a class="header-anchor" href="#追问-rsa-有什么缺陷吗" aria-label="Permalink to &quot;（追问）RSA 有什么缺陷吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>最大问题是服务端私钥泄漏。</p><p>使用 RSA 密钥协商算法的最大问题是<strong>不支持前向保密</strong>。</p><p>因为客户端传递随机数给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p></div><h2 id="ecdhe-了解吗" tabindex="-1">ECDHE 了解吗？ <a class="header-anchor" href="#ecdhe-了解吗" aria-label="Permalink to &quot;ECDHE 了解吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>ECDHE 解决了 RSA 私钥泄漏的问题，RSA 私钥泄漏会导致，第三方截取的之前 TLS 通讯都破解。造成这个问题的原因是 RSA 采用非对称加密，会采用服务器私钥来解密 pre-master 再生成会话密钥。</p><p>服务器私钥泄漏导致 会话密钥背破解。会话会被窃听</p><p>ECDHE 采用的对称加密，每次通信都会生成一个临时的会话密钥。</p><p>双方各自随机生成私钥d，基于椭圆基点生成公钥 Q，交换公钥，由于椭圆曲线的性质，dQ = dQ，那么这个结果就是预共享密钥，再交换随机数作为加强安全性的保障。</p><p>即使服务器私钥泄漏也不能解密之前的会话信息，因为每次通信的会话密钥是临时生成的，都不一致，而且不会被破解，离散对数还很难有解</p><p>在这个过程中一共有 4 个随机数，有 2 个是私钥，2个是用于加强安全性的</p></div><h2 id="ecdhe-的握手过程" tabindex="-1">ECDHE 的握手过程？ <a class="header-anchor" href="#ecdhe-的握手过程" aria-label="Permalink to &quot;ECDHE 的握手过程？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>第一次握手会向服务端打招呼 Client Hello，把 TLS 版本号，套件信息，生成的客户端随机数发给服务端</li><li>第二次握手服务端会发送打招呼「Server Hello」消息，把确认的 TLS 版本号，生成的服务端随机数，以及在客户端的密码套件列表中选择密码套件 <ul><li>还会继续发送 CA 证书</li><li>因为选择了 ECDHE 密码套件，还会<strong>生成随机数作为服务端椭圆曲线的私钥</strong>，保留到本地；根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。</li><li>公钥还会通过 RSA 进行加密，防止被篡改</li><li>第二次握手完后的状态是共享了：Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</li></ul></li><li>第三次握手，校验证书，校验完成。会生成随机数作为自己的私钥，根据基点 G 计算得到客户端公钥。用对方的公钥 * 自己的私钥得到预共享密钥，这个预共享密钥服务端也能算出一样的值，但这个不是最终的共享密钥 <ul><li>为了保证共享密钥的随机性，需要将预共享密钥和随机数一起计算得到共享密钥</li><li>处理完后，告诉服务端采用共享密钥通信</li><li>还会发送会话摘要，确保不被篡改</li></ul></li><li>第四次握手，服务端相同操作，发回 Change Cipher Spec ，Finish</li></ol></div><h2 id="追问-ecdhe-握手和-rsa-握手有什么区别" tabindex="-1">（追问）ECDHE 握手和 RSA 握手有什么区别 <a class="header-anchor" href="#追问-ecdhe-握手和-rsa-握手有什么区别" aria-label="Permalink to &quot;（追问）ECDHE 握手和 RSA 握手有什么区别&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>最重要的一点就是 ECDHE 每次会话密钥都是不一样的，保证了数据向前的安全性（一次破解并不影响历史信息的性质就是向前安全性），而 RSA 是用公钥和私钥加解密，是长期的密钥。</li><li>ECDHE 采用椭圆加密算法，有更高的安全性，</li><li>握手过程也不一样，RSA 会用公钥加密预共享生成的共享密钥，发送这个预共享密钥给服务端，服务端解出预共享密钥。ECDHE 会各自生成临时私钥，交换公钥，根据自己的私钥和对方的公钥算出预共享密钥</li><li>ECDHE 发完第三次握手信息，就可以直接发送 HTTP 数据，不用等收到最后一次的 TLS 握手。而 RSA 需要等待完成第四次握手后，才发送加密数据。</li></ol></div><h2 id="https-和-http-的区别" tabindex="-1">HTTPS 和 HTTP 的区别？ <a class="header-anchor" href="#https-和-http-的区别" aria-label="Permalink to &quot;HTTPS 和 HTTP 的区别？&quot;">​</a></h2><ol><li>HTTP 是明文传输，存在安全风险，HTTPS 加入 TLS 协议，使得加密传输</li><li>HTTP 只需要三次握手就可以进行传输，HTTPS 还需要 TLS 握手过程</li><li>两者端口号不同 HTTPS 443，HTTP 80</li><li>HTTPS 需要 CA 授权数字证书，确保服务器可信</li></ol><h2 id="https-解决了-http-的哪些问题" tabindex="-1">HTTPS 解决了 HTTP 的哪些问题？ <a class="header-anchor" href="#https-解决了-http-的哪些问题" aria-label="Permalink to &quot;HTTPS 解决了 HTTP 的哪些问题？&quot;">​</a></h2><ol><li>HTTP 明文传输，存在被窃听、篡改、冒充的风险，HTTPS 加了 TLS 确保通信安全，</li><li>混合加密防止被窃听，摘要算法实现完整性，有点类似于指纹，防止会话被篡改</li><li>采用数字证书，防止被冒充</li></ol><h2 id="https-通信时间总和是多少" tabindex="-1">HTTPS 通信时间总和是多少？ <a class="header-anchor" href="#https-通信时间总和是多少" aria-label="Permalink to &quot;HTTPS 通信时间总和是多少？&quot;">​</a></h2><p>HTTPS 基于 TLS1.2 通信时间总和 = TCP 建立连接时间 + TLS 连接时间 + HTTP交易时间 = 1 RTT + 2 RTT + 1 RTT = 4 RTT</p><p>HTTPS 通信时间总和（基于TLS1.3） = TCP 建立连接时间 + TLS1.3 连接时间 + HTTP交易时间 = 1 RTT + 1 RTT + 1 RTT = 3 RTT</p><h2 id="https-是如何保证安全性的" tabindex="-1">HTTPS 是如何保证安全性的？ <a class="header-anchor" href="#https-是如何保证安全性的" aria-label="Permalink to &quot;HTTPS 是如何保证安全性的？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>HTTPS 在 HTTP 的基础上加了 TLS 验证，在 TCP 三次握手后，还需要经过 TLS 握手，通信期间会用会话密钥进行加密，确保了安全性，也防止会话被窃听，TLS 在握手最后还会生成摘要进行验证，防止会话被篡改</p><p>HTTPS 还需要服务器去进行数字证书认证，防止服务器被冒充</p></div>',24),T=[s];function o(r,h,p,c,d,n){return l(),t("div",null,T)}const H=a(e,[["render",o]]);export{S as __pageData,H as default};
