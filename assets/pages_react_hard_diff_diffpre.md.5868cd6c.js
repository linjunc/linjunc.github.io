import{_ as a,c as e,o as s,V as o}from"./chunks/framework.3d11d069.js";const n="/assets/1.b88e114e.png",t="/assets/2.2103a8ea.png",l="/assets/3.f96de5e5.png",r="/assets/4.cfe8183a.png",p="/assets/5.720b76e8.png",u=JSON.parse('{"title":"diff 算法流程概览","description":"","frontmatter":{},"headers":[],"relativePath":"pages/react/hard/diff/diffpre.md","filePath":"pages/react/hard/diff/diffpre.md","lastUpdated":1690513358000}'),c={name:"pages/react/hard/diff/diffpre.md"},i=o(`<h1 id="diff-算法流程概览" tabindex="-1">diff 算法流程概览 <a class="header-anchor" href="#diff-算法流程概览" aria-label="Permalink to &quot;diff 算法流程概览&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>在 <code>beginWork</code>那一节我们知道了，在 <code>reconcileChildren</code> 中，会根据当前的 <code>current</code> 是否存在，来判断是进入 <code>update</code> 还是 <code>mount</code> 的逻辑<br>在 <code>update</code>时，会维护两棵虚拟 DOM 树，React 在每次更新时，都会将本次的新的内容与旧的 Fiber 树进行对比，通过 Diff 算法比较他们之间的差异后，构建新的 Fiber 树，将计算好的需要更新的节点放入更新队列中，从而在 commti 阶段，依据这个 Diff 结果，对真实 DOM 进行更新渲染。<br>这样可以确保通过<strong>最小的代价来将旧的 Fiber 树转化为新的 Fiber 树</strong>，以保证 UI 与新的树保持同步</p><h2 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h2><p>虚拟 DOM ，它是一种编程概念，在这个概念里，以一种<strong>虚拟的表现形式被保存在内存</strong>中。在 React 中，render 执行的结果得到的并不是真正的 DOM 节点，而是 JavaScript 对象</p><blockquote><p>虚拟 DOM 只保留了真实 DOM 节点的一些<strong>基本属性，和节点之间的层次关系</strong>，它相当于建立在 JavaScript 和 DOM 之间的一层“缓存”</p></blockquote><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">hello world!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>上面的这段代码会转化可以转化为虚拟 DOM 结构</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        class</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[{</span></span>
<span class="line"><span style="color:#A6ACCD;">        tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">span</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">        children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello world!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>其中对于一个节点必备的<strong>三个属性</strong> <code>tag、props、children</code></p><ul><li>tag 指定元素的<strong>标签</strong>类型，如<code>li</code>，<code>div</code></li><li>props 指定元素身上的属性，如 <code>class</code> ，<code>style</code>，自定义属性</li><li>children 指定元素是否有<strong>子节点</strong>，参数以<strong>数组</strong>形式传入</li></ul><p>而我们在 render 中编写的 JSX 代码就是一种虚拟 DOM 结构。</p><h2 id="diff-策略" tabindex="-1">Diff 策略 <a class="header-anchor" href="#diff-策略" aria-label="Permalink to &quot;Diff 策略&quot;">​</a></h2><p>那么基于多叉树的 Diff 算法，如果需要完整的对比之间的差异，<strong>复杂度会达到 O(n^3)</strong>，也就是 1000 个元素需要进行 10 亿次的比较，这个开销非常之大，React <strong>基于一些策略</strong>，来实现了 O(n) 复杂度的 Diff 算法</p><ol><li>只对<strong>同级元素</strong>进行 diff ，如果 dom 前后两次更新跨层级，不会复用，而作为新元素</li><li>两个<strong>不同类型的元素</strong>会产生出不同的树。如 div 变成 p 会将整棵树销毁</li><li>可以通过** key** 来暗示不同的渲染下保持稳定</li></ol><p><img src="`+n+'" alt="image.png" data-fancybox="gallery"><br>而针对这三种策略，分别对应着** **<code>tree diff</code>，<code>component diff</code> 以及 <code>element diff</code> 来进行算法优化</p><h3 id="按-tree-层级-diff" tabindex="-1">按 Tree 层级 Diff <a class="header-anchor" href="#按-tree-层级-diff" aria-label="Permalink to &quot;按 Tree 层级 Diff&quot;">​</a></h3><p>首先会将新旧两个 DOM 树，进行比较，这个比较指的是<strong>分层比较</strong>。又由于 DOM 节点<strong>跨层级的移动操作很少，忽略不计</strong>。React 通过 <code>updataDepth</code> 对 虚拟 DOM 树进行层级控制，只会对同层节点进行比较，也就是图中只会对相同颜色方框内的 DOM 节点进行比较。例如：<br><strong>当对比发现节点消失时，则该节点及其子节点都会被完全删除，不会进行更深层次的比较</strong>，这样只需要对树进行一次遍历，便能完成整颗 DOM 树的比较<br><img src="'+t+'" alt="image.png" data-fancybox="gallery"></p><p>这里还有一个值得关注的地方：<strong>DOM 节点跨层级移动</strong><br>为什么会提出这样的问题呢，在上面的删除原则中，我们发现当节点不存在了就会删除，那我只是给它换位了，它也会删除整个节点及其子节点吗？<br><img src="'+l+'" alt="image.png" data-fancybox="gallery"><br>如图，我们需要实现这样的移动，你可能会以为它会直接这样移动<br><img src="'+r+'" alt="image.png" data-fancybox="gallery"><br>但是实际情况，并不是这样的。由于 React 只会简单的进行同层级节点位置变化，对于不同层级的节点，只有创建和删除操作，当发现 B 节点消失时，就会<strong>销毁 B</strong>，当发现 C 节点上多了 B 节点，就会创建 B 以及它的子节点。<br><strong>因此这样会非常的复杂，所以 React 官方并不建议我们进行 DOM 节点跨级操作</strong></p><h3 id="按-component-层级-diff" tabindex="-1">按 component 层级 diff <a class="header-anchor" href="#按-component-层级-diff" aria-label="Permalink to &quot;按 component 层级 diff&quot;">​</a></h3><p>在组件层面上，也进行了优化</p><ul><li>如果是同一类型的组件，则按照原策略继续比较 虚拟 DOM Tree</li><li>如果不是，则将这个组件记为 <code>dirty component</code> ，从而<strong>替换整个组件下的所有子节点</strong></li></ul><p>同时对于同一类型的组件，有可能其 <code>Virtual DOM</code> 没有任何变化，如果能够确切的知道这点就可以节省大量的 <code>diff</code> 运算的时间，因此 <code>React</code> 允许用户通过 <code>shouldComponentUpdate()</code> 判断该组件是否需要进行 <code>diff</code> 算法分析<br>总的来说，<strong>如果两个组件结构相似，但被认定为了不同类型的组件，则不会比较二者的结构，而是直接删除</strong></p><h3 id="按-element-层级-diff" tabindex="-1">按 element 层级 diff <a class="header-anchor" href="#按-element-层级-diff" aria-label="Permalink to &quot;按 element 层级 diff&quot;">​</a></h3><p>element diff 是专门针对<strong>同一层级的所有节点</strong>的策略。当节点在同一层级时，diff 提供了 3个节点操作方法：插入，移动，删除<br>当我们要完成如图所示操作转化时，会有很大的困难，因为在新老节点比较的过程中，发现每个节点都要<strong>删除再重新创建</strong>，但是这只是重新排序了而已，对性能极大的不友好。因此 React 中提出了优化策略：<br>允许添加<strong>唯一值 key 来区分节点</strong><br><img src="'+p+'" alt="image.png" data-fancybox="gallery"><br>引入 key 的优化策略，让性能上有了翻天覆地的变化</p><h4 id="那-key-有什么作用呢" tabindex="-1">那 key 有什么作用呢？ <a class="header-anchor" href="#那-key-有什么作用呢" aria-label="Permalink to &quot;那 key 有什么作用呢？&quot;">​</a></h4><p>当同一层级的节点添加了 key 属性后，当位置发生变化时。react diff 进行新旧节点比较，如果发现有相同的 key 就会进行移动操作，而不会删除再创建</p><h4 id="那-key-具体是如何起作用的呢" tabindex="-1">那 key 具体是如何起作用的呢？ <a class="header-anchor" href="#那-key-具体是如何起作用的呢" aria-label="Permalink to &quot;那 key 具体是如何起作用的呢？&quot;">​</a></h4><p>首先在 React 中只允许<strong>节点右移</strong><br>因此对于上图中的转化，只会进行 A，C 的移动<br>则只需要对移动的节点进行更新渲染，不移动的则不需要更新渲染</p><h4 id="为什么不能用-index-作为-key-值呢" tabindex="-1">为什么不能用 index 作为 key 值呢？ <a class="header-anchor" href="#为什么不能用-index-作为-key-值呢" aria-label="Permalink to &quot;为什么不能用 index 作为 key 值呢？&quot;">​</a></h4><p><code>index</code> 作为 <code>key</code> ，如果我们删除了一个节点，那么数组的后一项可能会前移，这个时候移动的节点和删除的节点就是相同的 <code>key</code>  ，在<code>react</code>中，如果 <code>key</code> 相同，就会视为<strong>相同的组件</strong>，但这两个组件是不同的，这样就会出现很麻烦的事情，例如：序号和文本不对应等问题<br>所以一定要保证 <code>key</code> 的唯一性</p><h2 id="建议" tabindex="-1">建议 <a class="header-anchor" href="#建议" aria-label="Permalink to &quot;建议&quot;">​</a></h2><p>React 已经帮我们做了很多了，剩下的需要我们多加注意，才能有更好的性能<br>基于三个策略我们需要注意</p><ul><li><strong>tree diff 建议</strong>：开发组件时，需要注意保持 DOM 结构稳定</li><li><strong>component diff 建议</strong>：使用 <code>shouldComponentUpdate()</code> 来减少不必要的更新</li><li><strong>element diff 建议</strong>：减少最后一个节点移动到头部的操作，这样前面的节点都需要移动</li></ul><hr><p>下节开始，我们将会介绍 React 源码中的 <strong>Diff 算法</strong>的实现，它可以根据<strong>同级节点的数量分为两类</strong></p><ul><li>一种是用于 <code>object</code>、<code>number</code>、<code>string</code> 类型的节点，这些都是单一节点的 Diff</li><li>一种是 <code>array</code> 类型的多节点 Diff</li></ul><p>我们将分为两节来介绍，下节介绍单一节点的 Diff 算法</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p><a href="https://segmentfault.com/a/1190000016539430" target="_blank" rel="noreferrer">谈谈React中Diff算法的策略及实现</a><br><a href="https://segmentfault.com/a/1190000011492275" target="_blank" rel="noreferrer">React diff算法</a><br><a href="https://juejin.cn/post/6967626390380216334#heading-1" target="_blank" rel="noreferrer">浅谈react 虚拟dom，diff算法与key机制</a></p><hr>',41),d=[i];function f(D,g,y,h,F,m){return s(),e("div",null,d)}const C=a(c,[["render",f]]);export{u as __pageData,C as default};
