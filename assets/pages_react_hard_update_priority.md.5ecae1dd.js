import{_ as s,c as o,o as a,V as n}from"./chunks/framework.3d11d069.js";const l="/assets/tree.3d4e8154.png",d=JSON.parse('{"title":"优先级更新","description":"","frontmatter":{},"headers":[],"relativePath":"pages/react/hard/update/priority.md","filePath":"pages/react/hard/update/priority.md","lastUpdated":1691330952000}'),p={name:"pages/react/hard/update/priority.md"},e=n(`<h1 id="优先级更新" tabindex="-1">优先级更新 <a class="header-anchor" href="#优先级更新" aria-label="Permalink to &quot;优先级更新&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>在 React 18 的更新中，全面启用了 <code>concurrent</code> 模式，使用 <code>legacy</code> 模式将会报 <strong>warning 警告</strong>，可以看出 <code>concurrent</code> 模式会是 React 的未来。<br><code>legacy</code> 模式是我们之前常用的，它<strong>构建 dom 的过程是同步的</strong>，所以在 <code>reconcile</code> 阶段的 Diff 中，如果特别耗时，那么导致的结果就是 js 会一直<strong>阻塞高优先级的任务</strong>，表现为页面的卡顿和无法响应。<br><code>concurrent</code> 模式是 react 18 中全面开启的模式，它用<strong>时间片调度实现了异步可中断</strong>的任务，根据设备性能的不同，时间片的长度也不一样，在每个时间片中，如果任务到了过期时间，就会主动让出线程给高优先级的任务。<br>采用 <code>ReactDOM.render</code> 来渲染的应用，就是 <code>legacy</code> 模式，都是同步的，在状态更新时没有优先级的概念，任务之间需要依次执行。<br>对于 <code>concurrent</code> 模式和 <code>blocking</code> 模式来说，也就是采用 <code>ReactDOM.createRoot</code> 或 <code>ReactDOM.createBlockingRoot</code> 创建的应用，会采用并发的方式来更新状态。<strong>当有高优先级任务存在时，会中断当前正在执行的低优先级任务，先完成高优先级更新后，再基于更新结果重新进行低优先级的更新。</strong></p><blockquote><p>blocking mode 是实验中的模式，为了 legacy 迁移至 concurrent 而存在</p></blockquote><p><strong>那么什么是优先级呢？</strong></p><h2 id="优先级与update" tabindex="-1">优先级与Update <a class="header-anchor" href="#优先级与update" aria-label="Permalink to &quot;优先级与Update&quot;">​</a></h2><blockquote><p>优先级的概念只存在与 concurrent 模式中</p></blockquote><p>React 源码中优先级的分类，一共有以下 6 种优先级</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PriorityLevel</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// TODO: Use symbols?</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> NoPriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ImmediatePriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 最高</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> UserBlockingPriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 用户触发的更新，onClick 等</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> NormalPriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 一般的优先级，请求数据更新状态</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> LowPriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// </span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> IdlePriority </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 空闲优先级</span></span></code></pre></div><p>优先级的计算公式，只执行<strong>高于本次更新</strong>的优先级的 Update<br>baseState + Update1（NormalPriority） + Update2（UserBlockingPriority） = newState<br>对于上面的公式来说，<code>Update2</code> 的优先级高于 <code>Update1</code>，那么会先执行 <code>Update2</code> 的更新，再基于 <code>Update2</code> 更新的结果进行 <code>Update1</code> 的更新，也就是下面两步</p><ol><li><code>baseState</code> + <code>Update2</code> = <code>newState1</code></li><li><code>newState1</code> + <code>Update1</code> = <code>newState</code></li></ol><p>在知道了不同事件触发更新的优先级之后，我们再来看看它的更新流程</p><h2 id="更新流程" tabindex="-1">更新流程 <a class="header-anchor" href="#更新流程" aria-label="Permalink to &quot;更新流程&quot;">​</a></h2><p>在上面我们知道了不同优先级的更新会有中断的可能，那么具体流程是怎么样的呢，我们通过下面这个例子来了解一下<br>下图是一个组件树的结构，F 组件触发了一次更新，它的优先级是 <strong>NormalPriority</strong>。<br>可以假设是在 <code>componentDidMount</code> 中去请求了一次数据，在请求成功后调用了 <code>setState</code> 去更新状态，这里调用 <code>setState</code> 就会创建一次更新，因此这个更新的优先级是 <strong>NormalPriority</strong><br><img src="`+l+`" alt="image.png" data-fancybox="gallery"></p><ul><li>首先它会从当前的 Fiber 节点，也就是 F 节点，开始向上遍历，并通知沿途的 Fiber 节点有更新，一直到 <code>FiberRootNode</code>，在 <code>FiberRootNode</code> 上保存当前更新的优先级，在这里就是 <strong>NormalPriority</strong></li><li>接下来，就会以 <strong>NormalPriority</strong> 优先级，来调度整个应用的根节点 <code>FiberRootNode</code>，整个应用中只有一个被调度的任务，它的优先级是 <strong>NormalPriority</strong>，于是就调用 <strong>NormalPriority</strong> 的回调函数，这个回调函数就是 <code>render</code> 阶段的入口，由于优先级是作用在<strong>整个组件树</strong>的，我们会从 <code>FiberRootNode</code> 开始向下，采用深度优先遍历的方式，依次以 <strong>NormalPriority</strong> 来执行每一个组件的 Diff</li><li>在这个组件树中，只有 F 组件存在 <strong>NormalPriority</strong> 优先级对应的 Update，因此只有 F 组件会在 Diff 中得到一个 state</li><li>如果在这个计算过程中，F 组件<strong>又触发了一次更新</strong>，这个更新的优先级是 <code>UserBlockingPriority</code>，那么又会从 F 组件向上遍历，直到 <code>FiberRootNode</code>，mark 一下</li><li>注册一个 <code>UserBlockingPriority</code> 的调度，接下来 scheduler 就会调度，<strong>NormalPriority</strong> 和 <code>UserBlockingPriority</code>，<code>UserBlockingPriority</code> 的优先级高于 <strong>NormalPriority</strong></li><li>因此之前正在执行的 <strong>NormalPriority</strong> 的 <code>render</code> 阶段就会被中断，重新从根节点向下深度优先遍历，执行 <code>UserBlockingPriority</code> 优先级的更新</li><li>在执行完 <code>render --&gt; commit</code> 阶段后，基于当前的计算结果，再去执行刚刚被中断的低先级的更新</li></ul><h2 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h2><blockquote><p>例子学习自：<a href="https://react.iamkasong.com/" target="_blank" rel="noreferrer">React 技术揭秘</a></p></blockquote><p>在下面的例子中，通过 <code>useEffect</code> 触发了两个更新，一个是 <code>useState</code> 的回调更新，一个是<strong>事件触发的更新</strong>，<code>onClick</code> 触发的更新优先级比 <code>normal</code> 要高，又因为我们两次更新时间间隔很短，并且操作很多，第一次更新还没有在 20ms 内完成就触发了优先级更高的更新，因此会调度 <code>normal</code> 和 <code>userBlocking</code> 两个优先级的事件，<code>userBlocking</code> 优先级的更新，会中断正在执行的 <code>normal</code> 的 render 阶段<br>因此页面会从 0 变为 2 再变为 3</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> updateCount</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> buttonRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useRef</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> onClick </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">updateCount</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">count</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">button</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">buttonRef</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">current</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">updateCount</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">button</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">click</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1020</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;">[])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">App</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">buttonRef</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">onClick</span><span style="color:#89DDFF;">}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      增加 2</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4000</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">v</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">index</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        ))</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>以上的讨论都是基于 concurrent mode 下进行的，如果是在同步模式下，也就是 ReactDOM.render ，页面的结果展示将会是从 0 变为 1 变为 3，这是因为同步模式下没有优先级的概念，不会中断第一次的 updateCount</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p><a href="https://react.iamkasong.com/" target="_blank" rel="noreferrer">React 技术揭秘</a></p>`,22),t=[e];function c(r,y,D,F,C,i){return a(),o("div",null,t)}const g=s(p,[["render",c]]);export{d as __pageData,g as default};
