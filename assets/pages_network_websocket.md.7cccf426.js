import{_ as e,c as o,o as t,U as c}from"./chunks/framework.4d5e0f31.js";const h=JSON.parse('{"title":"WebSocket 相关面试题","description":"","frontmatter":{},"headers":[],"relativePath":"pages/network/websocket.md","lastUpdated":1680375359000}'),a={name:"pages/network/websocket.md"},s=c(`<h1 id="websocket-相关面试题" tabindex="-1">WebSocket 相关面试题 <a class="header-anchor" href="#websocket-相关面试题" aria-label="Permalink to &quot;WebSocket 相关面试题&quot;">​</a></h1><h2 id="你可以说说你对-websocket-的理解吗" tabindex="-1">你可以说说你对 Websocket 的理解吗？ <a class="header-anchor" href="#你可以说说你对-websocket-的理解吗" aria-label="Permalink to &quot;你可以说说你对 Websocket 的理解吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>WebSocket 它是一种在客户端和服务器之间<strong>建立持久连接</strong>的协议，它在单个 TCP 连接上实现全双工通信，实现了高效率的双向通信。</p><p>在传统的 HTTP 协议中都是一种请求和响应的模式，只有客户端发送请求后，服务器才能返回响应的结果，这种对于实时性要求高的场景就很不利，而 WebSocket 可以保持连接状态，避免了频繁的请求和响应操作。</p><p>它最大的特点是<strong>服务器可以向客户端主动推动消息，客户端也可以向服务器端发送消息</strong></p></div><h2 id="追问-websocket-的特点又哪些呢" tabindex="-1">（追问）WebSocket 的特点又哪些呢？ <a class="header-anchor" href="#追问-websocket-的特点又哪些呢" aria-label="Permalink to &quot;（追问）WebSocket 的特点又哪些呢？&quot;">​</a></h2><ul><li>支持双向通信，实时性很强</li><li>可以发送文本和二进制数据</li><li>建立在 TCP 协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL</li><li>与 HTTP 协议有着不错的兼容性，默认端口是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li></ul><h2 id="追问-即时通讯的实现方式有哪些" tabindex="-1">（追问）即时通讯的实现方式有哪些？ <a class="header-anchor" href="#追问-即时通讯的实现方式有哪些" aria-label="Permalink to &quot;（追问）即时通讯的实现方式有哪些？&quot;">​</a></h2><p>短轮询、长轮询、SSE、WebSocket</p><h2 id="追问-说说它们的实现思路" tabindex="-1">（追问）说说它们的实现思路？ <a class="header-anchor" href="#追问-说说它们的实现思路" aria-label="Permalink to &quot;（追问）说说它们的实现思路？&quot;">​</a></h2><p><strong>短轮询</strong>：客户端每隔一段时间向浏览器发送 HTTP 请求，服务器端收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的的即时通讯，其实是一种<strong>间隔性的轮询</strong>，因此叫做短轮询。</p><p>它的缺点也非常明显，这种方式需要不断的建立 HTTP 连接，严重浪费服务器端和客户端资源。</p><p><strong>长轮询</strong>：客户端向服务器端发送 HTTP 请求，服务器端收到请求后，不会立即返回响应，而是<strong>将请求挂起</strong>，在服务器端有更新的时候进行响应，或者在达到一定时间后进行返回。</p><p>相比之下，长轮询的方式减少了 HTTP 请求的次数，但是连接挂起也会导致资源的浪费</p><p><strong>SSE</strong>：服务器使用流信息向服务器推送信息。严格来说，HTTP 协议无法实现服务器主动推送信息。但是如果<strong>服务器向客户端声明，需要发送流数据</strong>。也就是说，发送的不是一次性的数据包，而是一个数据流，会不断的发送，这时，客户端不会关闭连接，会等着服务器发过来新的数据流。</p><p>相比于短轮询和长轮询来说避免建立过多的 HTTP 请求，相比之下更加节约资源</p><p><strong>WebSocket</strong>：与传统的 HTTP 协议不同，该协议允许由服务器主动向客户端推送信息。它是全双工通信协议，可以互发信息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><h2 id="怎么判断协议是不是-websocket" tabindex="-1">怎么判断协议是不是 WebSocket？ <a class="header-anchor" href="#怎么判断协议是不是-websocket" aria-label="Permalink to &quot;怎么判断协议是不是 WebSocket？&quot;">​</a></h2><p><code>WebSocket</code> 使用 <code>ws</code> 或 <code>wss</code> 的统一资源标志符，通过判断 header 中是否包含 <code>Connection: Upgrade</code> 和 <code>Upgrade: WebSocket</code> 来判断当前是否需要升级到 <code>Websocket</code> 协议，同时还有一些 <code>Version</code> 的 header，当服务器同意升级 <code>Websocket</code> 后会返回 101 的响应码</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Upgrade</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> websocket</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Connection</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Upgrade</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Sec</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">WebSocket</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> x3JJHMbDL1EzLkh9GBhXDw</span><span style="color:#89DDFF;">==</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">Sec</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">WebSocket</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Protocol</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> chat</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> superchat</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">Sec</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">WebSocket</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Version</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">13</span></span>
<span class="line"></span></code></pre></div><ul><li>首先，<code>Sec-WebSocket-Key</code> 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是 Websocket 助理。</li><li>然后，<code>Sec_WebSocket-Protocol</code> 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务 A，别搞错啦~</li><li>最后，<code>Sec-WebSocket-Version</code> 是告诉服务器所使用的 <code>Websocket Draft</code>（协议版本），在最初的时候，Websocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 Websocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦大家都使用的一个东西 ：服务员，我要的是13岁的噢→_→</li></ul><h2 id="http-和-websocket-的区别" tabindex="-1">HTTP 和 WebSocket 的区别 <a class="header-anchor" href="#http-和-websocket-的区别" aria-label="Permalink to &quot;HTTP 和 WebSocket 的区别&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>首先第一点是 HTTP 是<strong>无状态协议</strong>，每次请求和响应之间不会保存任何的信息，而 WebSocket 是有状态的，连接一旦建立，客户端和服务器之间的通信可以一直保持，直到连接关闭。</p><p>第二点是 HTTP 基于请求和响应的方式，而 WebSocket 支持<strong>双向通信</strong>，客户端和服务器之间可以同时发送信息</p><p>第三点 HTTP 的<strong>连接是短暂的</strong>，每次请求完成后都会关闭，而 WebSocket 使用长连接，连接一旦建立就可以一直保持，发送多次数据，减少网络传输和时间开销</p><p>第四点 HTTP 每次请求都需要<strong>建立 TCP 连接</strong>，而 WebSocket 只需要建立一次 TCP 连接，后续的通信都是基于这个连接，减少了建立连接的时间开销</p></div><h2 id="追问-http-也有长连接-为什么不使用呢-它和-websocket-有什么区别呢" tabindex="-1">（追问）HTTP 也有长连接，为什么不使用呢，它和 WebSocket 有什么区别呢？ <a class="header-anchor" href="#追问-http-也有长连接-为什么不使用呢-它和-websocket-有什么区别呢" aria-label="Permalink to &quot;（追问）HTTP 也有长连接，为什么不使用呢，它和 WebSocket 有什么区别呢？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>确实是，HTTP 中有 keep-alive 的机制来保持连接，但是它的实现方式是在请求头中加入 <code>Connection: keep-alive</code> 来保持连接，而 WebSocket 是在握手阶段就将连接升级为长连接，这样就避免了每次请求都要加入 <code>Connection: keep-alive</code> 的请求头。</p><p>因此可以看出，HTTP 实现的长连接<strong>每次都需要发送报文头部</strong>，而 WebSocket 则不需要发送报文头部，可以直接发送消息，这样就大大减少了数据传输量，提高了传输效率。</p><p>其实意思就是说：HTTP 的长连接是保持了 TCP 连接，可以发送多个 HTTP 请求，减少了握手次数。</p><p>同时，WebSocket 支持双向通信，而 HTTP 长连接通信是单向的，</p></div><p>HTTP1.1 的连接<strong>默认使用长连接</strong></p><p>即在一定的期限内保持链接，客户端会需要在短时间内向服务端请求大量的资源，保持 TCP 连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p><p>在一个 TCP 连接上可以传输多个 <code>Request/Response</code> 消息对，所以本质上还是 <code>Request/Response</code> 消息对，仍然会造成资源的浪费、实时性不强等问题。</p><p>如果不是持续连接，即短连接，那么每个资源都要建立一个新的连接，HTTP 底层使用的是 TCP，那么每次都要使用三次握手建立 TCP 连接，即每一个 request 对应一个 response，将造成极大的资源浪费。</p><h2 id="websocket-的握手过程" tabindex="-1">WebSocket 的握手过程 <a class="header-anchor" href="#websocket-的握手过程" aria-label="Permalink to &quot;WebSocket 的握手过程&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>WebSocket 的握手过程使用的是 HTTP 协议，首先会像服务端发送一个 HTTP 请求，其中<strong>包含了需要升级 WebSocket 请求的头部信息，Upgrade 和 Connection 等</strong>，服务端接收到请求后，会验证请求是否合法，返回 HTTP 响应，其中包含了 WebSocket-Accept 的字段，用于确认服务器是否支持 WebSocket 协议，并对连接请求进行验证，验证通过，那么就会升级协议，之后的通信就是基于 WebSocket 协议了。</p></div><ol><li><p>客户端向服务端<strong>发送 HTTP 请求报文</strong>。报文中必须包含一些特殊的头部信息，例如 Host、Upgrade、Connection、<code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Version</code> 等。其中，<code>Sec-WebSocket-Key</code> 是一个随机字符串，用于验证客户端的身份。</p></li><li><p>服务端接收到客户端的请求后，判断该请求<strong>是否是有效的 WebSocket 请求</strong>。如果请求不合法，则返回 400 Bad Request 响应报文。否则，服务端向客户端返回一个 HTTP 响应报文。响应报文中必须包含 Upgrade、Connection、<code>Sec-WebSocket-Accept</code> 和 <code>Sec-WebSocket-Version</code> 字段，其中：</p></li></ol><ul><li><p><code>Upgrade</code>：值必须为 &quot;websocket&quot;，表示客户端请求升级到 WebSocket 协议。</p></li><li><p><code>Connection</code>：值必须为 &quot;<code>Upgrade</code>&quot;，表示客户端请求升级连接。</p></li><li><p><code>Sec-WebSocket-Accept</code>：该字段的值是由服务端生成的，用于验证客户端的身份是否合法。</p></li><li><p><code>Sec-WebSocket-Version</code>：该字段的值是一个整数，表示支持的 WebSocket 版本号。如果服务端不支持客户端请求的版本，则会返回一个 426 Upgrade Required 响应报文。</p></li></ul><ol start="3"><li><p>客户端接收到服务端的响应后，首先要验证响应报文的状态码<strong>是否为 101 Switching Protocols</strong>。如果状态码不是这个值，则表示握手失败。否则，客户端需要验证响应报文中的 <code>Sec-WebSocket-Accept</code> 字段值是否正确。具体地，客户端需要将其自己保存的 GUID（Globally Unique Identifier）字符串和之前发送的随机字符串 <code>Sec-WebSocket-Key</code> 拼接在一起，计算 SHA1 摘要，然后将结果转换为 BASE64 编码。最终结果应该和服务端返回的 <code>Sec-WebSocket-Accept</code> 字段值相同。</p></li><li><p>如果客户端验证成功，表示 WebSocket 连接已经<strong>建立成功</strong>。此时，客户端和服务端可以开始进行数据传输。在数据传输过程中，客户端和服务端之间互相发送数据帧（Frame），每个数据帧包含了一个消息的一部分或全部内容。同时，也可以使用 Ping/Pong 消息来检测连接状态。当连接不再需要时，客户端或服务端可以发送 Close 消息来关闭连接。</p></li></ol><h2 id="追问-你刚刚提到的验证是指什么-是如何验证的" tabindex="-1">（追问）你刚刚提到的验证是指什么，是如何验证的？ <a class="header-anchor" href="#追问-你刚刚提到的验证是指什么-是如何验证的" aria-label="Permalink to &quot;（追问）你刚刚提到的验证是指什么，是如何验证的？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在 WebSocket 握手中，客户端会向服务器发送一个 HTTP 请求，请求头中包含了一些信息，其中就包括了一个随机生成的字符串，即 <code>Sec-WebSocket-Key</code>。服务器收到这个请求后，会根据一定的规则对这个字符串进行处理，以验证连接请求的合法性。</p><p>具体来说，服务器会将 <code>Sec-WebSocket-Key</code> 和一个固定的字符串（&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;）拼接在一起，然后对这个字符串进行 SHA-1 摘要计算，并进行 base64 编码，得到一个新的字符串，即 Sec-WebSocket-Accept。服务器会将这个字符串作为响应头中的一个字段返回给客户端。</p><p>客户端收到服务器的响应后，会检查其中是否存在 <code>Sec-WebSocket-Accept</code> 字段，并且会用相同的方法计算出自己的 <code>Sec-WebSocket-Accept</code> 值。如果两者相等，说明连接请求是合法的，握手成功。此时，服务器和客户端就可以使用 WebSocket 协议进行实时通信了。</p><p>简单来说，<code>Sec-WebSocket-Key</code> 是一个随机字符串，用于确保客户端发送的连接请求是合法的；而 <code>Sec-WebSocket-Accept</code> 则是服务器计算出的响应头字段，用于确认服务器是否支持 WebSocket 协议，并对连接请求进行验证。</p></div><p><code>Sec-WebSocket-Key</code> 并<strong>不是用来保证安全性的</strong>，只是用来验证是否是合法的 WebSocket 请求。如果想要保证安全性，可以使用 SSL/TLS 协议对 WebSocket 连接进行加密。</p><h2 id="websocket-的一些应用场景和优缺点" tabindex="-1">WebSocket 的一些应用场景和优缺点 <a class="header-anchor" href="#websocket-的一些应用场景和优缺点" aria-label="Permalink to &quot;WebSocket 的一些应用场景和优缺点&quot;">​</a></h2><p>WebSocket 的特性决定了它的使用场景，用于一些实时性和双向通信低延迟的场景，比如实时通信在线聊天、在线游戏、视频会议等。</p><p>它的优点也很明显</p><ol><li>实时性好，服务端可以主动推送数据</li><li>节省带宽：WebSocket 使用长连接，可以减少建立和断开连接的开销</li><li>开发成本低：不需要学习新的协议，因为类似 HTTP 接口</li><li>支持跨域</li></ol><p>缺点就兼容性、稳定性、和安全问题吧</p><h2 id="websocket-协议的-api-如何在-javascript-中实现" tabindex="-1">WebSocket 协议的 API 如何在 JavaScript 中实现 <a class="header-anchor" href="#websocket-协议的-api-如何在-javascript-中实现" aria-label="Permalink to &quot;WebSocket 协议的 API 如何在 JavaScript 中实现&quot;">​</a></h2><h2 id="websocket-的生命周期及其与-http-协议的关系" tabindex="-1">WebSocket 的生命周期及其与 HTTP 协议的关系 <a class="header-anchor" href="#websocket-的生命周期及其与-http-协议的关系" aria-label="Permalink to &quot;WebSocket 的生命周期及其与 HTTP 协议的关系&quot;">​</a></h2><h2 id="websocket-消息传输的优化" tabindex="-1">WebSocket 消息传输的优化 <a class="header-anchor" href="#websocket-消息传输的优化" aria-label="Permalink to &quot;WebSocket 消息传输的优化&quot;">​</a></h2><h2 id="websocket-与-ajax-长轮询-服务器推送的区别是什么" tabindex="-1">WebSocket 与 Ajax/长轮询/服务器推送的区别是什么？ <a class="header-anchor" href="#websocket-与-ajax-长轮询-服务器推送的区别是什么" aria-label="Permalink to &quot;WebSocket 与 Ajax/长轮询/服务器推送的区别是什么？&quot;">​</a></h2><h2 id="websocket-有多少种状态-分别是什么" tabindex="-1">WebSocket 有多少种状态？分别是什么？ <a class="header-anchor" href="#websocket-有多少种状态-分别是什么" aria-label="Permalink to &quot;WebSocket 有多少种状态？分别是什么？&quot;">​</a></h2><h2 id="websocket-的特点有哪些-与传统请求和响应相比有何优势" tabindex="-1">WebSocket 的特点有哪些？与传统请求和响应相比有何优势？ <a class="header-anchor" href="#websocket-的特点有哪些-与传统请求和响应相比有何优势" aria-label="Permalink to &quot;WebSocket 的特点有哪些？与传统请求和响应相比有何优势？&quot;">​</a></h2><h2 id="如何在服务器端实现-websocket-基于-node-js-的实现方式是什么" tabindex="-1">如何在服务器端实现 WebSocket？基于 Node.js 的实现方式是什么？ <a class="header-anchor" href="#如何在服务器端实现-websocket-基于-node-js-的实现方式是什么" aria-label="Permalink to &quot;如何在服务器端实现 WebSocket？基于 Node.js 的实现方式是什么？&quot;">​</a></h2><h2 id="多通道的工作原理是什么" tabindex="-1">多通道的工作原理是什么？ <a class="header-anchor" href="#多通道的工作原理是什么" aria-label="Permalink to &quot;多通道的工作原理是什么？&quot;">​</a></h2>`,49),l=[s];function n(p,r,i,d,b,k){return t(),o("div",null,l)}const T=e(a,[["render",n]]);export{h as __pageData,T as default};
