import{_ as s,c as a,o,V as e}from"./chunks/framework.3d11d069.js";const h=JSON.parse('{"title":"React 入门学习（十二）-- React 路由跳转","description":"在学习了路由之后，我们可以来做很多的事情，例如跨页面的通信通信，这就离不开路由传参了，params，search等...","frontmatter":{"title":"React 入门学习（十二）-- React 路由跳转","date":"2021-09-06T14:29:48.000Z","id":1635582588,"tags":["react"],"categories":["React入门学习"],"keywords":"React,路由传参,小丞","description":"在学习了路由之后，我们可以来做很多的事情，例如跨页面的通信通信，这就离不开路由传参了，params，search等..."},"headers":[],"relativePath":"pages/react/primary/react-router.md","filePath":"pages/react/primary/react-router.md","lastUpdated":1689053292000}'),t={name:"pages/react/primary/react-router.md"},l=e('<p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-%E8%B7%AF%E7%94%B1.gif" alt="React路由" data-fancybox="gallery"></p><blockquote><p>📢 大家好，我是小丞同学，一名<div color="#2e86de"><strong>大二的前端爱好者</strong></div></p><p>📢 这篇文章是学习 React 中 React 路由跳转的学习笔记</p><p>📢 非常感谢你的阅读，不对的地方欢迎指正 🙏</p><p>📢 <div color="#f368e0"><strong>愿你忠于自己，热爱生活</strong></div></p></blockquote><h2 id="_1-push-与-replace-模式" tabindex="-1">1. push 与 replace 模式 <a class="header-anchor" href="#_1-push-与-replace-模式" aria-label="Permalink to &quot;1. push 与 replace 模式&quot;">​</a></h2><p>默认情况下，开启的是 push 模式，也就是说，每次点击跳转，都会向栈中压入一个新的地址，在点击返回时，可以返回到上一个打开的地址，</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-push.gif" alt="react-router-push" data-fancybox="gallery"></p><p>就像上图一样，我们每次返回都会返回到上一次点击的地址中</p><p>当我们在读消息的时候，有时候我们可能会不喜欢这种繁琐的跳转，我们可以开启 replace 模式，这种模式与 push 模式不同，它会将当前地址<strong>替换</strong>成点击的地址，也就是替换了新的栈顶</p><p>我们只需要在需要开启的链接上加上 <code>replace</code> 即可</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">replace</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">to</span><span style="color:#89DDFF;">={{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">pathname</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/home/message/detail</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">state</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> msgObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">title</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> msgObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">title </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}}&gt;{</span><span style="color:#A6ACCD;">msgObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">title</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#FFCB6B;">Link</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/react-router-replace.gif" alt="react-router-replace" data-fancybox="gallery"></p><h2 id="_2-编程式路由导航" tabindex="-1">2. 编程式路由导航 <a class="header-anchor" href="#_2-编程式路由导航" aria-label="Permalink to &quot;2. 编程式路由导航&quot;">​</a></h2><p>我们可以采用绑定事件的方式实现路由的跳转，我们在按钮上绑定一个 <code>onClick</code> 事件，当事件触发时，我们执行一个回调 <code>replaceShow</code></p><p>这个函数接收两个参数，用来仿制默认的跳转方式，第一个是点击的 id 第二个是标题</p><p>我们在回调中，调用 <code>this.props.location</code> 对象下的 replace 方法</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">replaceShow</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">id</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">title</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">/home/message/detail/</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">title</span><span style="color:#89DDFF;">}`</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>同时我们可以借助 <code>this.props.history</code> 身上的 API 实现路由的跳转，例如 <code>go</code>、<code>goBack</code> 、<code>goForward</code></p><h2 id="_3-withrouter" tabindex="-1">3. withRouter <a class="header-anchor" href="#_3-withrouter" aria-label="Permalink to &quot;3. withRouter&quot;">​</a></h2><p>当我们需要在页面内部添加回退前进等按钮时，由于这些组件我们一般通过一般组件的方式去编写，因此我们会遇到一个问题，<strong>无法获得 history 对象</strong>，这正是因为我们采用的是一般组件造成的。</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210906231051190.png" alt="image-20210906231051190" data-fancybox="gallery"></p><p>只有路由组件才能获取到 history 对象</p><p>因此我们需要如何解决这个问题呢</p><p>我们可以利用 <code>react-router-dom</code> 对象下的 <code>withRouter</code> 函数来对我们导出的 <code>Header</code> 组件进行包装，这样我们就能获得一个拥有 <code>history</code> 对象的一般组件</p><p>我们需要对哪个组件包装就在哪个组件下引入</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Header/index.jsx</span></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">withRouter</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react-router-dom</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 在最后导出对象时，用 `withRouter` 函数对 index 进行包装</span></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">withRouter</span><span style="color:#A6ACCD;">(index)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>这样就能让一般组件获得路由组件所特有的 API</p><h2 id="_4-browserrouter-和-hashrouter-的区别" tabindex="-1">4. BrowserRouter 和 HashRouter 的区别 <a class="header-anchor" href="#_4-browserrouter-和-hashrouter-的区别" aria-label="Permalink to &quot;4. BrowserRouter 和 HashRouter 的区别&quot;">​</a></h2><h4 id="它们的底层实现原理不一样" tabindex="-1"><strong>它们的底层实现原理不一样</strong> <a class="header-anchor" href="#它们的底层实现原理不一样" aria-label="Permalink to &quot;**它们的底层实现原理不一样**&quot;">​</a></h4><p>对于 BrowserRouter 来说它使用的是 React 为它封装的 history API ，这里的 history 和浏览器中的 history 有所不同噢！通过操作这些 API 来实现路由的保存等操作，但是这些 API 是 H5 中提出的，因此不兼容 IE9 以下版本。</p><p>对于 HashRouter 而言，它实现的原理是通过 URL 的哈希值，但是这句话我不是很理解，用一个简单的解释就是</p><p>我们可以理解为是锚点跳转，因为锚点跳转会保存历史记录，从而让 HashRouter 有了相关的前进后退操作，HashRouter 不会将 <code>#</code> 符号后面的内容请求。兼容性更好！</p><h4 id="地址栏的表现形式不一样" tabindex="-1">地址栏的表现形式不一样 <a class="header-anchor" href="#地址栏的表现形式不一样" aria-label="Permalink to &quot;地址栏的表现形式不一样&quot;">​</a></h4><ul><li>HashRouter 的路径中包含 <code>#</code> ，例如 <code>localhost:3000/#/demo/test</code></li></ul><h4 id="刷新后路由-state-参数改变" tabindex="-1">刷新后路由 state 参数改变 <a class="header-anchor" href="#刷新后路由-state-参数改变" aria-label="Permalink to &quot;刷新后路由 state 参数改变&quot;">​</a></h4><ol><li>在BrowserRouter 中，state 保存在history 对象中，刷新不会丢失</li><li>HashRouter 则刷新会丢失 state</li></ol>',34),p=[l];function n(r,c,i,y,D,d){return o(),a("div",null,p)}const A=s(t,[["render",n]]);export{h as __pageData,A as default};
