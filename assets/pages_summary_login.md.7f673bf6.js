import{_ as o,c as e,o as a,Q as s}from"./chunks/framework.6e2cccc0.js";const u=JSON.parse('{"title":"面对前端鉴权登录，你需要知道的一切。从 Cookie 到 JWT、从 Session 到 SSO","description":"","frontmatter":{},"headers":[],"relativePath":"pages/summary/login.md","lastUpdated":1679771997000}'),i={name:"pages/summary/login.md"},t=s(`<h1 id="面对前端鉴权登录-你需要知道的一切。从-cookie-到-jwt、从-session-到-sso" tabindex="-1">面对前端鉴权登录，你需要知道的一切。从 Cookie 到 JWT、从 Session 到 SSO <a class="header-anchor" href="#面对前端鉴权登录-你需要知道的一切。从-cookie-到-jwt、从-session-到-sso" aria-label="Permalink to &quot;面对前端鉴权登录，你需要知道的一切。从 Cookie 到 JWT、从 Session 到 SSO&quot;">​</a></h1><p>在 Web 应用中，用户身份认证和授权是非常重要的一部分。为了确保应用程序的安全性和可靠性，前端鉴权登录技术成为了一个不可或缺的话题。同时在面试当中前端鉴权登录也会经常被提到相关的问题：</p><ul><li>你的登录是如何实现的？</li><li>登录状态是如何维持的？</li><li>如何实现退出登录？</li><li>...</li></ul><p>这篇文章将通过介绍 <code>Cookie</code>、<code>Session</code>、<code>JWT</code>、<code>SSO</code>、<code>oAuth</code> 等技术，来帮助你理解前端鉴权登录的实现原理、它们的优缺点以及它们的适用场景，以便于你在实战中能够更好的选择合适的技术来实现前端鉴权登录，同时能在面试中娓娓道来。</p><p>首先，我们需要知道为什么会有这些技术的出现，它们是为了解决什么问题的呢？</p><h2 id="http-是无状态的" tabindex="-1">HTTP 是无状态的 <a class="header-anchor" href="#http-是无状态的" aria-label="Permalink to &quot;HTTP 是无状态的&quot;">​</a></h2><p>我们都知道 HTTP 是无状态的，在每次服务端接收到客户端的请求时，都会是个全新的请求，服务器并不知道这个请求<strong>是谁发起的，也不知道这个请求是不是第一次发起的，也不知道这个请求是不是最后一次发起的</strong>。这就意味着，每次请求都是独立的，服务器不会记录任何请求的信息，也不会记录任何客户端的信息。</p><p>举个具体的场景来说：</p><blockquote><p>我们在访问一些电商网站时，我们会<strong>挑选商品到购物车，然后结账</strong>。如果我们在结账时，服务器不知道我们是谁，那么我们就需要在结账时，<strong>再次输入我们的用户名和密码</strong>，这样服务器才能知道我们是谁，才能完成结账的操作。</p></blockquote><p>这样的操作显然是不合理的，我们在结账时，服务器应该知道我们是谁，而不是再次输入用户名和密码。</p><p>这种不合理的方式的出现也源于 <strong>HTTP 是无状态的，服务器无法记住用户的信息。</strong></p><p>那么，如果 HTTP 有了状态，那么服务端就可以记住用户信息，<strong>为什么不将 HTTP 设计成有状态的呢？</strong></p><h3 id="为什么-http-不设计成有状态的呢-而是无状态的呢" tabindex="-1">为什么 HTTP 不设计成有状态的呢，而是无状态的呢？ <a class="header-anchor" href="#为什么-http-不设计成有状态的呢-而是无状态的呢" aria-label="Permalink to &quot;为什么 HTTP 不设计成有状态的呢，而是无状态的呢？&quot;">​</a></h3><p>在设计之处的考虑，一方面是为了<strong>提高协议的可扩展性和灵活性</strong>，确保它可以适用于各种不同的应用场景。另一方面是为了减轻服务器的负担，使其更加轻量级。因此选择了无状态的设计。</p><p>如果 HTTP 直接是有状态的，那么服务端需要跟踪每个客户端的状态信息，这样会使得服务器的<strong>负担变大</strong>，而且也会使得服务器的可扩展性变差。</p><p>而如果是无状态的，服务器只专注于处理一个单独的请求，不需要跟踪状态信息。同时这也<strong>促使了客户端和服务器解耦</strong>，每个请求都是独立的，不依赖服务器，更加灵活和动态。</p><p>那么，在 HTTP 无状态的情况下，我们如何实现状态的维持呢？</p><h3 id="认证标记" tabindex="-1">认证标记 <a class="header-anchor" href="#认证标记" aria-label="Permalink to &quot;认证标记&quot;">​</a></h3><p>接着上面电商的例子来说，我们可以使用认证标记来维持状态</p><p>我们在登录这个电商网站的时候，给你发个<strong>通行证</strong>，这样你可以拿着<strong>通行证</strong>，在这个网站里到处逛。</p><blockquote><p>就像在公司里，你会拿着公司的门禁卡， 门禁卡上有你的信息，这样你就可以在公司里到处走动。</p></blockquote><p>你在这个网站里逛了一圈，然后你想结账，你就拿着你的<strong>通行证</strong>去结账，这样在你结账的时候，就可以<strong>出示你的通行证</strong>，这样就可以知道你是谁了，就可以完成结账的操作。</p><p>因此，诞生了这一系列的设计，从网景公司发明的 Cookie，到后来 <code>Session</code>、<code>LocalStorage</code>、<code>IndexDB</code> 等技术，都为客户端处理状态信息提供了很多的解决方案。</p><h2 id="根基-cookie" tabindex="-1">根基 Cookie <a class="header-anchor" href="#根基-cookie" aria-label="Permalink to &quot;根基 Cookie&quot;">​</a></h2><p>Cookie 是一种存储方式，它是为了解决 HTTP 无状态导致无法跟踪用户信息而出现的。</p><p>它的出现，使得我们可以在客户端存储一些信息，然后在后续的请求中，<strong>自动带上这些信息，这样就可以实现状态的维持。</strong></p><p>相比于 <code>LocalStorage</code>、<code>SessionStorage</code> 等方式，Cookie 借助浏览器的能力，可以实现跨域存储，同时可以做到前端无感知，HTTP 请求自动带上 Cookie。</p><h3 id="cookie-实现状态维持的流程是怎么样的呢" tabindex="-1">Cookie 实现状态维持的流程是怎么样的呢？ <a class="header-anchor" href="#cookie-实现状态维持的流程是怎么样的呢" aria-label="Permalink to &quot;Cookie 实现状态维持的流程是怎么样的呢？&quot;">​</a></h3><ol><li>首先客户端向服务端发送请求时，服务端在 HTTP 响应头中添加一个 <code>Set-Cookie</code> 字段，这个字段的值就是 Cookie 的值。包含了<strong>唯一的会话标识</strong>，客户端浏览器会把它存到本地。</li><li>当客户端再次向服务端发送请求时，都会自动带上这个 Cookie，服务端就可以通过这个 Cookie 来<strong>识别客户端的身份</strong>。</li></ol><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/imgtwo/20230326012705.png" alt="" data-fancybox="gallery"></p><blockquote><p>服务端返回的 set-cookie 字段</p></blockquote><p>Cookie 还有一些常用的配置项，比如 <code>domain</code>、<code>path</code>、<code>expires</code>、<code>httpOnly</code> 等，这些配置项可以用来控制 Cookie 的作用域，以及 Cookie 的有效期。</p><ul><li><code>domain</code>：指定 Cookie 的<strong>作用域</strong>，如果不指定，默认是当前域名。如果指定了，那么 Cookie 只能在指定的域名下使用。</li><li><code>expires</code>：指定 Cookie 的<strong>过期时间</strong>，如果不指定，默认是会话结束时过期。</li><li><code>httpOnly</code>: 指定该 Cookie 是否只能通过 HTTP 协议来访问，如果设置了这个属性，那么通过 JS 脚本是无法访问这个 Cookie 的。</li><li>...</li></ul><p>这里需要特别说到 <code>httpOnly</code> 属性，因为它是 Cookie 的一个重要属性。</p><p>对于前端而言，我们可以<strong>自己创建 Cookie，也可以修改 Cookie</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">cookie </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxxx</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;">// 伪代码</span></span>
<span class="line"></span></code></pre></div><p>当然这些操作只对 <code>httpOnly</code> 为 false 的 Cookie 有效，如果是 <code>httpOnly</code> 为 true 的 Cookie，那么就无法通过 JS 来操作了。</p><p>因此，我们可以通过设置 <code>httpOnly</code> 为 true 来防止 XSS 攻击。</p><p>此外 Secure 也需要特别提一下，它是用来指定 Cookie 是否只能通过 HTTPS 协议来传输，如果设置了这个属性，那么通过 HTTP 协议是无法传输这个 Cookie 的。</p><p>它为网站提供了一定的安全性！</p><p>但不管如何，Cookie 还是通过明文传输的，还是会有一定的安全隐患。</p><h3 id="需要注意的安全问题" tabindex="-1">需要注意的安全问题 <a class="header-anchor" href="#需要注意的安全问题" aria-label="Permalink to &quot;需要注意的安全问题&quot;">​</a></h3><p>主要有两个方面的问题：</p><ol><li>Cookie 劫持</li><li>XSS 攻击</li></ol><h4 id="cookie-劫持" tabindex="-1">Cookie 劫持 <a class="header-anchor" href="#cookie-劫持" aria-label="Permalink to &quot;Cookie 劫持&quot;">​</a></h4><p>通过<strong>中间人攻击，拦截用户的 Cookie</strong>，然后再次发送给服务端，这样就可以伪装成用户，从而获取用户的信息。</p><p>我们可以通过</p><ul><li>升级为 HTTPS 协议加密传输数据，可以有效的防止中间人攻击和黑客窃听。</li><li>同时可以限制 Cookie 的过期时间，缩短 Cookie 有效时间，来减少 Cookie 劫持的风险。</li><li>还可以设置 <code>HttpOnly</code> 和 Secure 属性，限制 Cookie 只能在 HTTPS 协议下传输，避免被 XSS 攻击窃取。</li></ul><h4 id="xss-攻击" tabindex="-1">XSS 攻击 <a class="header-anchor" href="#xss-攻击" aria-label="Permalink to &quot;XSS 攻击&quot;">​</a></h4><p>在前面也有提到，客户端可以直接操作 Cookie，那么就会有被 XSS 攻击的风险，攻击者将恶意脚本注入到网页中，从而获取 Cookie 信息。</p><p>我们可以通过以下这些方式来预防 XSS 攻击：</p><ul><li>对用户输入数据进行<strong>过滤和验证</strong>，确保所有输入的数据都符合预期。</li><li>使用 <strong>CSP</strong> 来限制脚本执行的域，防止XSS攻击。</li><li>设置 <code>httpOnly</code> 为 true</li></ul><h3 id="理清-cookie-工作流程" tabindex="-1">理清 Cookie 工作流程 <a class="header-anchor" href="#理清-cookie-工作流程" aria-label="Permalink to &quot;理清 Cookie 工作流程&quot;">​</a></h3><p>在我们首次登录这个网站时，服务端会在 HTTP 响应头中添加 <code>Set-Cookie</code> 字段，携带 cookie 的值，cookie 的值是在服务器生成的，主要是 cookie 关联的域名、过期时间、安全连接、用户数据等内容。</p><p>在下次请求时，浏览器会<strong>自动</strong>带上这个 Cookie，服务端就可以通过这个 Cookie 来识别客户端的身份，进行鉴权。</p><p><strong>Cookie 作为维持 HTTP 请求状态的根基</strong>，大多数前端鉴权问题都是依靠 Cookie 解决的，比如下面提到的 Session 方式</p><h2 id="服务端-session" tabindex="-1">服务端 Session <a class="header-anchor" href="#服务端-session" aria-label="Permalink to &quot;服务端 Session&quot;">​</a></h2><p>Session 也是 Web 应用程序中常用的会话跟踪机制。它是一种<strong>在服务器端存储用户状态信息的机制</strong>，通常用于存储用户的身份认证信息、会话标识符等敏感数据。</p><p>它与 Cookie 不同，Session 会将用户的数据存储在服务端，并且会更具加密算法确保它的安全性。</p><h3 id="session-登录流程" tabindex="-1">Session 登录流程 <a class="header-anchor" href="#session-登录流程" aria-label="Permalink to &quot;Session 登录流程&quot;">​</a></h3><p>Session 的实现方式是当客户端第一次向服务器发送请求时，服务器会为该客户端<strong>创建一个唯一的 SessionID</strong>，并在自己的内存中存储 Session 数据，Session ID 则通过响应头部中的 <code>Set-Cookie</code> 字段返回给客户端浏览器。客户端再次向服务器发送请求时，会携带该 Session ID，服务端根据 Session ID 获取对应的 Session 数据以判断用户的会话状态。</p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/imgtwo/20230326020507.png" alt="" data-fancybox="gallery"></p><blockquote><p>上图是在掘金上看到的，很清晰</p></blockquote><ol><li>首先客户端登录网站，发送账号密码给服务端。服务端校验密码是否成功</li><li>生成一个 SessionId，把登录状态存到服务端的 session 中</li><li>通过 <code>Set-Cookie</code> 把 SessionId 写入到 Cookie 中，返回给客户端</li><li>此后浏览器再请求，都会自动带上 cookie</li><li>服务端会根据 cookie 中的 SessionId 找到对应的 session，从而判断用户是否登录</li><li>成功后，返回数据给客户端</li></ol><blockquote><p>可以把 session 理解为一个 Map，是键值对的形式，key 是 sessionId，value 的内容可以是用户信息，登录状态都可以</p></blockquote><h3 id="那么-session-如何实现退出登录呢" tabindex="-1">那么 Session 如何实现退出登录呢？ <a class="header-anchor" href="#那么-session-如何实现退出登录呢" aria-label="Permalink to &quot;那么 Session 如何实现退出登录呢？&quot;">​</a></h3><p>Cookie 那块没有讲退出登录的部分，这两个是一样的。</p><p>首先，退出登录无非就是<strong>将登录状态置为未登录</strong>，那么我们就需要清除掉 Session 中的登录状态，同时也需要清除掉 Cookie 中的 SessionId。</p><p><strong>那么如何清除 Cookie 中的 SessionId 呢？</strong></p><p>我们可以通过将 Cookie 的过期时间设置为<strong>一个过去的时间</strong>来实现。</p><h3 id="采用-cookie-服务端-session-会存在哪些安全问题呢" tabindex="-1">采用 cookie + 服务端 session 会存在哪些安全问题呢？ <a class="header-anchor" href="#采用-cookie-服务端-session-会存在哪些安全问题呢" aria-label="Permalink to &quot;采用 cookie + 服务端 session 会存在哪些安全问题呢？&quot;">​</a></h3><p>首先，<strong>cookie 本身是不安全的</strong>，因为它是明文传输的，所以很容易被窃取。因此攻击者可以通过获取用户的 SessionId 来伪造用户的身份，进行恶意操作。</p><p><strong>可以通过以下的方式预防</strong></p><ul><li>使用 <strong>HTTPS</strong> 协议加密传输数据，可以有效防止中间人攻击和黑客窃听。</li><li>生成<strong>随机且复杂</strong>的 Session ID，并设置合理的过期时间，避免被猜测或者重放攻击。</li><li>不要在 <strong>URL</strong> 中使用 Session ID，避免会话固定攻击。</li><li><strong>定期更换</strong> Session ID，以保证会话安全性。</li></ul><p>还有一种安全问题是攻击者使用已知的 Session ID 信息，直接访问用户的会话，从而获取用户的敏感信息。</p><p><strong>可以通过以下的方式预防</strong></p><ul><li>在会话开始时生成新的 Session ID，避免使用容易被猜测的 Session ID，例如递增的数字序列等。</li><li>使用 <code>HttpOnly</code> 和 <code>Secure</code> 属性限制 Cookie 只能在 HTTPS 协议下使用，防止被 XSS 攻击窃取。</li></ul><p>前面我们说了很多关于服务端 Session 的东西，它需要结合 Cookie 一起使用，那么如果客户端不支持 cookie 呢？这时候怎么办？</p><h3 id="url-重写-session" tabindex="-1">URL 重写 Session <a class="header-anchor" href="#url-重写-session" aria-label="Permalink to &quot;URL 重写 Session&quot;">​</a></h3><p>URL 重写 Session 是一种<strong>在 URL 中传递 Session ID 的方式</strong>，不需要在客户端和服务端之间保存 Session 数据，而是通过在 URL 中添加 Session ID 来实现会话跟踪。</p><p>例如，在会话 ID为 ljc 的应用程序中，可以使用以下URL：</p><p><code>http://linjunc.com/index.html?SESSIONID=ljc</code></p><p>然后服务端通过检查 URL 的参数来识别会话，和存在 Cookie 的方式一样，对于前端而言就是 SessionId 存在哪里的问题。</p><p>但是这个方案也只是一个无奈的选择，因为它<strong>不安全</strong>，因为 URL 是明文传输的，所以很容易被窃取，攻击者可以通过获取用户的 SessionId 来伪造用户的身份，进行恶意操作。同时在部署和维护上也会带来一些麻烦。</p><p>服务端 Session 的方式相较于 Cookie 而言，安全性更高一些，但是会有两个问题：</p><ol><li>首先服务端需要存储 Session，这样就会占用一定的内存，而且 Session 也是有过期时间的，所以需要定期清理过期的 Session，这样就会带来一些性能问题。</li><li>不同的服务器，无法共享 Session，通常需要借助 Redis （内存型数据库）解决</li></ol><h2 id="jwt-token" tabindex="-1">JWT Token <a class="header-anchor" href="#jwt-token" aria-label="Permalink to &quot;JWT Token&quot;">​</a></h2><p>前面我们说了 Cookie 和 Session 两种方案，存在着这些问题</p><ol><li>服务端 Session 需要在服务端维护，需要找地方保存它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。</li><li>都基于浏览器 Cookie 实现，用户禁用 Cookie 后，系统就无法正常使用了。</li></ol><p>那么有没有一种方案，可以解决这些问题呢？</p><p>JWT 就是这样一种方案，它是一种<strong>基于 Token 的身份认证机制</strong>，它的特点是<strong>无状态</strong>，也就是说，它不需要在服务端保存会话信息，也不需要在客户端保存会话状态。</p><h3 id="jwt-会话流程" tabindex="-1">JWT 会话流程 <a class="header-anchor" href="#jwt-会话流程" aria-label="Permalink to &quot;JWT 会话流程&quot;">​</a></h3><h3 id="jwt-的生成规则" tabindex="-1">JWT 的生成规则 <a class="header-anchor" href="#jwt-的生成规则" aria-label="Permalink to &quot;JWT 的生成规则&quot;">​</a></h3><h3 id="jwt-的优势" tabindex="-1">JWT 的优势 <a class="header-anchor" href="#jwt-的优势" aria-label="Permalink to &quot;JWT 的优势&quot;">​</a></h3><h3 id="jwt-存在的问题" tabindex="-1">JWT 存在的问题 <a class="header-anchor" href="#jwt-存在的问题" aria-label="Permalink to &quot;JWT 存在的问题&quot;">​</a></h3><h3 id="jwt-如何防止被篡改" tabindex="-1">JWT 如何防止被篡改 <a class="header-anchor" href="#jwt-如何防止被篡改" aria-label="Permalink to &quot;JWT 如何防止被篡改&quot;">​</a></h3><h3 id="如何实现退出登录" tabindex="-1">如何实现退出登录？ <a class="header-anchor" href="#如何实现退出登录" aria-label="Permalink to &quot;如何实现退出登录？&quot;">​</a></h3><h3 id="如何实现无感刷新" tabindex="-1">如何实现无感刷新？ <a class="header-anchor" href="#如何实现无感刷新" aria-label="Permalink to &quot;如何实现无感刷新？&quot;">​</a></h3><h2 id="oauth-2-0-的刷新机制" tabindex="-1">OAuth 2.0 的刷新机制 <a class="header-anchor" href="#oauth-2-0-的刷新机制" aria-label="Permalink to &quot;OAuth 2.0 的刷新机制&quot;">​</a></h2><h3 id="网页授权流程" tabindex="-1">网页授权流程 <a class="header-anchor" href="#网页授权流程" aria-label="Permalink to &quot;网页授权流程&quot;">​</a></h3><h3 id="refreshtoken-刷新机制" tabindex="-1">refreshToken 刷新机制 <a class="header-anchor" href="#refreshtoken-刷新机制" aria-label="Permalink to &quot;refreshToken 刷新机制&quot;">​</a></h3><h2 id="sso-单点登录" tabindex="-1">SSO 单点登录 <a class="header-anchor" href="#sso-单点登录" aria-label="Permalink to &quot;SSO 单点登录&quot;">​</a></h2><h3 id="sso-登录流程" tabindex="-1">SSO 登录流程 <a class="header-anchor" href="#sso-登录流程" aria-label="Permalink to &quot;SSO 登录流程&quot;">​</a></h3><h4 id="sso-未登录" tabindex="-1">SSO 未登录 <a class="header-anchor" href="#sso-未登录" aria-label="Permalink to &quot;SSO 未登录&quot;">​</a></h4><h4 id="sso-已登录" tabindex="-1">SSO 已登录 <a class="header-anchor" href="#sso-已登录" aria-label="Permalink to &quot;SSO 已登录&quot;">​</a></h4><h3 id="sso-存在的问题" tabindex="-1">SSO 存在的问题 <a class="header-anchor" href="#sso-存在的问题" aria-label="Permalink to &quot;SSO 存在的问题&quot;">​</a></h3><h3 id="如何防止-ticket-被篡改" tabindex="-1">如何防止 ticket 被篡改？ <a class="header-anchor" href="#如何防止-ticket-被篡改" aria-label="Permalink to &quot;如何防止 ticket 被篡改？&quot;">​</a></h3><h3 id="如何防止-ticket-被盗用" tabindex="-1">如何防止 ticket 被盗用？ <a class="header-anchor" href="#如何防止-ticket-被盗用" aria-label="Permalink to &quot;如何防止 ticket 被盗用？&quot;">​</a></h3><h3 id="防重放攻击" tabindex="-1">防重放攻击 <a class="header-anchor" href="#防重放攻击" aria-label="Permalink to &quot;防重放攻击&quot;">​</a></h3><h2 id="如何选择合适的前端鉴权方式" tabindex="-1">如何选择合适的前端鉴权方式？ <a class="header-anchor" href="#如何选择合适的前端鉴权方式" aria-label="Permalink to &quot;如何选择合适的前端鉴权方式？&quot;">​</a></h2><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2>`,111),n=[t];function l(r,c,h,d,p,k){return a(),e("div",null,n)}const g=o(i,[["render",l]]);export{u as __pageData,g as default};
