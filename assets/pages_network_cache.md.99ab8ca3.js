import{_ as e,c as o,o as c,V as d}from"./chunks/framework.3d11d069.js";const f=JSON.parse('{"title":"浏览器缓存","description":"","frontmatter":{},"headers":[],"relativePath":"pages/network/cache.md","filePath":"pages/network/cache.md","lastUpdated":1687192689000}'),t={name:"pages/network/cache.md"},a=d('<h1 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h1><h2 id="介绍一下浏览器的缓存机制-它是怎么工作的" tabindex="-1">介绍一下浏览器的缓存机制，它是怎么工作的？ <a class="header-anchor" href="#介绍一下浏览器的缓存机制-它是怎么工作的" aria-label="Permalink to &quot;介绍一下浏览器的缓存机制，它是怎么工作的？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li><p>浏览器<strong>第一次加载资源</strong>，服务端返回 <code>200</code>，浏览器从服务器下载资源文件，并缓存资源文件和响应头 <code>response header</code>，以供下次加载时对比使用。</p></li><li><p>在第二次加载资源时，由于<strong>强缓存的优先级更高</strong>，先比较当前时间与上一次返回 <code>200</code> 时的时间差，如果没有超过 <code>cache-control</code> 设置的 <code>max-age</code>，则表示缓存还没有过期，命中强缓存，直接从本地读取资源。如果浏览器不支持 <code>HTTP1.1</code>，则使用 <code>expires</code> 头来判断是否过期。</p></li><li><p>如果资源已经过期，则表示强缓存没有被命中，则开始协商缓存，向服务器发送带有 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 的请求</p></li><li><p>服务器收到请求后，优先根据 <code>ETag</code> 的值判断被请求的文件有没有被修改，<code>ETag</code> 值一致则没有修改，命中协商缓存，返回 <code>304</code>；如果不一致则表明有改动，直接返回新的资源文件，并带上新的 <code>ETag</code> 值 和 <code>200</code> 的状态码</p></li><li><p>如果服务器收到的请求没有 <code>ETag</code> 值，则将 <code>If-Modified-Since</code> 的值与服务器上的文件最后修改时间进行对比，如果一致则命中协商缓存，返回 <code>304</code>；如果不一致则表明有改动，直接返回新的资源文件，并带上新的 <code>Last-Modified</code> 值 和 <code>200</code> 的状态码</p></li></ol></div><p>总的来说顺序就是</p><p><strong><code>cache-control &gt; expires &gt; ETag &gt; Last-Modified</code></strong></p><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/imgtwo/20230329005119.png" alt="" data-fancybox="gallery"></p><p>需要特别注意的是</p><p><code>Expires</code> 标头也可以指定缓存过期时间，例如 <code>Expires: Thu, 30 Dec 2021 12:00:00 GMT</code> 表示资源在该日期之前可被缓存。但这种方式已经不太常用，因为它依赖于<strong>客户端和服务器端的时间同步</strong>，容易出现问题。</p><p><code>Last-Modified</code> 和 <code>ETag</code> 则用于检查资源是否发生变化。<code>Last-Modified</code> 指定了资源的最后修改时间，而 <code>ETag</code> 是服务器生成的唯一标识符。<strong>当浏览器第一次请求资源时</strong>，服务器会将这些信息一起返回。<strong>当浏览器再次请求资源时</strong>，它会将上次请求中响应头中的这些信息包含在 <code>if-modified-since</code> 或 <code>if-none-match</code> 请求头中。如果资源没有变化，则服务器将返回一个状态码为 <code>304</code> 的响应，告诉浏览器<strong>可以使用缓存中的资源</strong>。</p>',9),s=[a];function i(r,n,p,l,g,h){return c(),o("div",null,s)}const m=e(t,[["render",i]]);export{f as __pageData,m as default};
