import{_ as a,c as e,o as r,V as t}from"./chunks/framework.3d11d069.js";const u=JSON.parse('{"title":"🍬 为什么 CSS 动画比 JavaScript 高效？","description":"引言 讲到动画，当然是非常有意思的啦，你可以往上滑一下，看看上面的封面图，是不是相当的炫酷，以为我是代码写出来的吗？","frontmatter":{"title":"🍬 为什么 CSS 动画比 JavaScript 高效？","date":"2021-08-01T23:40:41.000Z","id":1635420521,"photos":"https://ljcimg.oss-cn-beijing.aliyuncs.com/img/cssvsjs.gif","tags":["JavaScript","CSS"],"categories":[["前端总结","JavaScript精读"]],"keywords":"CSS,JavaScript,效率对比","description":"引言 讲到动画，当然是非常有意思的啦，你可以往上滑一下，看看上面的封面图，是不是相当的炫酷，以为我是代码写出来的吗？"},"headers":[],"relativePath":"pages/summary/animate.md","filePath":"pages/summary/animate.md","lastUpdated":1690032890000}'),o={name:"pages/summary/animate.md"},i=t('<blockquote><p>📢 大家好，我是小丞同学，一名<div color="#2e86de">准大二的前端爱好者</div></p><p>📢 这篇文章将<strong>欢快的</strong>带你了解一下 CSS 和 JS 动画的差别</p><p>📢 <div color="#f368e0"><strong>愿你忠于自己，热爱生活</strong></div></p></blockquote><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>讲到动画，当然是非常有意思的啦，你可以往上滑一下，看看上面的封面图，是不是相当的炫酷，以为我是代码写出来的吗？</p><p>那当然不可能啊，我这么摸鱼，怎么会为了个封面图上号呢</p><p>废话不多说，其实上面的动图用代码实现也不会很困难，这个图是用 canva 做出来的。</p><p>本文主要讲以下这些内容</p><ol><li>浏览器渲染流程</li><li>回流和重绘</li><li>CSS 动画</li><li>JS 动画</li><li>两者对比</li></ol><h2 id="🍉-1-浏览器的渲染流程" tabindex="-1">🍉 1. 浏览器的渲染流程 <a class="header-anchor" href="#🍉-1-浏览器的渲染流程" aria-label="Permalink to &quot;🍉 1. 浏览器的渲染流程&quot;">​</a></h2><p>渲染流程主要有4个步骤</p><ol><li>解析 HTML 生成DOM 树</li><li>解析 CSS 样式生成 CSSOM 树，CSSOM 树与 DOM 树结合生成 Render tree</li><li>布局 Render Tree 对每个节点进行布局处理，确定在屏幕上的位置</li><li>绘制 Render Tree，遍历渲染树将每个节点绘制出来</li></ol><p>为了优化用户体验，渲染引擎不会等到 HTML 解析完才创建布局渲染树</p><h3 id="生成-dom-树" tabindex="-1"><strong>生成 DOM 树</strong> <a class="header-anchor" href="#生成-dom-树" aria-label="Permalink to &quot;**生成 DOM 树**&quot;">​</a></h3><p>DOM 树的构建是一个深度遍历过程，也就是说只有在所有子节点都构建好后才会去构建当前节点的下一个兄弟节点</p><h3 id="生成-render-树" tabindex="-1"><strong>生成 Render 树</strong> <a class="header-anchor" href="#生成-render-树" aria-label="Permalink to &quot;**生成 Render 树**&quot;">​</a></h3><p>生成 DOM 树的同时会生成 CSSOM 树，根据 CSSOM 和 DOM 树构建 Render Tree，渲染树包括颜色，尺寸等显示属性的矩形</p><h3 id="dom-树和-render-树" tabindex="-1"><strong>DOM 树和 Render 树</strong> <a class="header-anchor" href="#dom-树和-render-树" aria-label="Permalink to &quot;**DOM 树和 Render 树**&quot;">​</a></h3><p><img src="https://ljcimg.oss-cn-beijing.aliyuncs.com/img/image-20210822213018363.png" alt="image-20210822213018363" data-fancybox="gallery"></p><h2 id="🍋-2-回流和重绘" tabindex="-1">🍋 2. 回流和重绘 <a class="header-anchor" href="#🍋-2-回流和重绘" aria-label="Permalink to &quot;🍋 2. 回流和重绘&quot;">​</a></h2><p>CSS 中至关重要的概念</p><h3 id="回流" tabindex="-1">回流 <a class="header-anchor" href="#回流" aria-label="Permalink to &quot;回流&quot;">​</a></h3><p>回流也叫<strong>重排</strong>，指<strong>几何属性</strong>需要改变的渲染。</p><p>每一次的回流都会将网页内容<strong>重新渲染</strong>，只是我们人眼感觉不到有任何变化，但是它确实是会清空页面的，再从页面的左上角的第一个像素点从左到右从上到下这样一点一点渲染，每次回流都会是这样的过程，只是感觉不到而已</p><blockquote><p>渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。</p></blockquote><p>常见的几何属性：布局，尺寸这些可以用尺子量出来的属性</p><ul><li>display、float、grid</li><li>width、padding</li></ul><p>等</p><h3 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h3><p>重绘指更改<strong>外观属性</strong>而不影响<strong>集合属性</strong>的渲染，类似于颜色这些。相比于回流，重绘的作用不会那么强烈。</p><p>渲染树的节点发生改变，但不影响该节点的集合属性，回流对浏览器性能的消耗是远大于重绘的。并且回流就必然带来重绘，重绘不一定需要回流</p><p><strong>外观属性</strong></p><ul><li>clip，background</li><li>text</li></ul><p>等</p><p>在介绍完这些知识后我们来聊聊 CSS 动画</p><h2 id="🍍-3-css3-动画" tabindex="-1">🍍 3. CSS3 动画 <a class="header-anchor" href="#🍍-3-css3-动画" aria-label="Permalink to &quot;🍍 3. CSS3 动画&quot;">​</a></h2><p>这里我们只谈论 CSS3 的动画</p><p>CSS3 动画也被称为补间动画，原因是只需要添加关键帧的位置，其他的未定义的帧会被自动生成</p><p>因为我们只设置了几个关键帧的位置，所以在进行动画控制的时候比较困难，不能再半路暂停动画，或者在动画过程中添加一些其他操作，都不大容易</p><p>但是 CSS 动画也有很多的好处</p><ul><li>浏览器可以对动画进行优化</li><li>帧速不好的浏览器，CSS3 可以自然降级兼容</li><li>代码简单，调优方向固定</li></ul><h2 id="🍎-4-js-动画" tabindex="-1">🍎 4. JS 动画 <a class="header-anchor" href="#🍎-4-js-动画" aria-label="Permalink to &quot;🍎 4. JS 动画&quot;">​</a></h2><p>首先，JS 动画是逐帧动画，在时间帧上绘制内容，一帧一帧的，所以他的可再造性很高，几乎可以完成任何你想要的动画形式。但是由于逐帧动画的内容不一样，会增加制作的负担，占用比较大的资源空间。</p><p>但是它也有很多的优势</p><ul><li>细腻的动画</li><li>可控性高</li><li>炫酷高级的动画</li></ul><h2 id="💯-5-css-动画与-js-动画对比" tabindex="-1">💯 5. CSS 动画与 JS 动画对比 <a class="header-anchor" href="#💯-5-css-动画与-js-动画对比" aria-label="Permalink to &quot;💯 5. CSS 动画与 JS 动画对比&quot;">​</a></h2><p>前面关于 CSS 动画和 JS 动画，都是一些概念性比较强的东西，不看也罢</p><p>说了这么多，到底为什么CSS动画要<strong>更高效</strong>呢？</p><h3 id="第一点" tabindex="-1"><strong>第一点</strong> <a class="header-anchor" href="#第一点" aria-label="Permalink to &quot;**第一点**&quot;">​</a></h3><p>从实现动画的复杂度来看，CSS 动画大多数都是补间动画，而 JS 动画是逐帧动画。当然这里我们不谈论实现的效果</p><h3 id="第二点" tabindex="-1"><strong>第二点</strong> <a class="header-anchor" href="#第二点" aria-label="Permalink to &quot;**第二点**&quot;">​</a></h3><p>编码的高效，采用 JS 去实现的动画，无论多简单的动画，都需要去控制整个过程，当然你可能会说可以采用一些库来解决这些问题，但是这些库的实际运行可能要比原生实现的效率要低的多</p><h3 id="第三点" tabindex="-1"><strong>第三点</strong> <a class="header-anchor" href="#第三点" aria-label="Permalink to &quot;**第三点**&quot;">​</a></h3><p>性能的高效，在我们前面讲到了回流和重绘，如果我们要操作一个元素向右移动，我们可能需要控制 <code>dom.style.left</code> 属性，每次来<strong>改变元素的位置</strong>，而结合我们所说的，<strong>几何属性</strong>的改变必然会引起<strong>回流</strong>，回流必然引起重绘，可想而知如果我们采用 JS 来实现动画，这个代价有多大，这会造成浏览器在不断的计算页面，从而导致浏览器内存堆积。同时由于 JavaScript 运行在浏览器的主线程中，主线程中还有其他的重要任务在运行，因而可能会受到干扰导致<strong>线程阻塞</strong>，从而<strong>丢帧</strong></p><p>而 CSS 的动画是运行在合成线程中的，不会阻塞主线程，并且在合成线程中完成的动作不会触发回流和重绘</p><p>当然还有一个重要的点：JS 动画运行在 CPU，而 CSS 动画运行在 GPU</p><p>总的来说， CSS动画的渲染成本小，并且它的执行效率高于 JavaScript 动画</p><hr><p>那我们什么时候使用 CSS 动画，什么时候使用 JS 动画呢？</p><p>我个人觉得</p><p><strong>只要能用 CSS 实现的动画，就不要采用 JS 去实现</strong>，可以多采用 CSS 预处理器去做更多复杂的动画，就像我之前用 SCSS 做的流星雨动画一样</p><p>如果动画相较复杂，我们可以采用 <code>JS + canvas</code> 去尝试，能不能实现</p><p>最后再考虑纯 JS 实现</p><hr><p>这篇文章可能还有很多值得探讨的地方，大佬们有什么看法或者不一样的见解可以一起交流以下~</p><blockquote><p>非常感谢您的阅读，欢迎提出你的意见，有什么问题欢迎指出，谢谢！🎈</p></blockquote>',64),l=[i];function n(s,p,d,S,c,h){return r(),e("div",null,l)}const m=a(o,[["render",n]]);export{u as __pageData,m as default};
